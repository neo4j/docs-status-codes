:description: This section describes the notifications that Neo4j can return, grouped by category, and an example of when they can occur.

[[listOfNnotifications]]
= List of notification codes

The following page provides an overview of all notifications in Neo4j, including the GQLSTATUS codes and Neo4j codes, along with some scenarios and their possible solutions.

* <<_performance_notifications, `PERFORMANCE` notifications>>
* <<_hint_notifications, `HINT` notifications>>
* <<_unrecognized_notifications, `UNRECOGNIZED` notifications>>
* <<_unsupported_notifications, `UNSUPPORTED` notifications>>
* <<_deprecated_notifications, `DEPRECATION` notifications>>
* <<_security_notifications, `SECURITY` notifications>>
* <<_topology_notifications, `TOPOLOGY` notifications>>
* <<_schema_notifications, `SCHEMA` notifications>>
* <<_generic, `GENERIC` notifications>>

[WARNING]
====
Please note that while GQLSTATUS codes remain stable (any changes to them will be breaking), changes to status descriptions associated with these codes are not breaking and may happen at any time.
For this reason, parsing the status descriptions or incorporating them into scripts is not recommended.
====

[#_performance_notifications]
== `PERFORMANCE` notifications

Performance notifications are returned whenever the query uses costly operations and the performance may be improved by changing the query or adding an index.

[#_neo_clientnotification_statement_cartesianproduct]
=== Cartesian product

This notification is returned when there is a Cartesian product in the plan.

.Notification details
[cols="<1s,<4"]
|===
|Neo4j code
m|Neo.ClientNotification.Statement.CartesianProduct
|Title
a|This query builds a cartesian product between disconnected patterns.
|Description
|If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (`%s`)
|Category
m|PERFORMANCE
|GQLSTATUS code
m|03N90
|Status description
a|info: cartesian product.
The disconnected patterns `{ $pat }` build a cartesian product.
A cartesian product may produce a large amount of data and slow down query processing.
|Classification
m|PERFORMANCE
|SeverityLevel
m|INFORMATION
|===


.A query that contains many disconnected patterns
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher, role="noplay"]
----
MATCH (c:Child), (p:Parent) RETURN c, p
----

Returned GQLSTATUS code::
03N90

Returned status description::
info: cartesian product.
The disconnected patterns `(c:Child), (p:Parent)` build a cartesian product.
A cartesian product may produce a large amount of data and slow down query processing.

Suggestions for improvement::
In case a Cartesian product is needed, nothing can be done to improve this query.
In many cases, however, you might not need a combination of all children and parents, and that is when this query could be improved.
If for example, you need the children and the children's parents, you can improve this query by rewriting it to the following:
+
[source, cypher, role="noplay"]
----
MATCH (c:Child)-[:ChildOf]->(p:Parent) RETURN c, p
----

======
[.include-with-neo4j--code]
======

Query::
+
[source, cypher, role="noplay"]
----
MATCH (c:Child), (p:Parent) RETURN c, p
----

Description of the returned code::
If a part of a query contains multiple disconnected patterns,
this will build a cartesian product between all those parts.
This may produce a large amount of data and slow down query processing.
While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product,
perhaps by adding a relationship between the different parts or by using `OPTIONAL MATCH` (identifier is: (`p`))

Suggestions for improvement::
In case a Cartesian product is needed, nothing can be done to improve this query.
In many cases, however, you might not need a combination of all children and parents, and that is when this query could be improved.
If for example, you need the children and the children's parents, you can improve this query by rewriting it to the following:
+
[source, cypher, role="noplay"]
----
MATCH (c:Child)-[:ChildOf]->(p:Parent) RETURN c, p
----

======
=====

[#_neo_clientnotification_statement_unboundedvariablelengthpattern]
=== Unbounded variable length pattern

This notification is returned when there is no upper bound specified on the variable length relationship.

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.UnboundedVariableLengthPattern
|Title
a|The provided pattern is unbounded, consider adding an upper limit to the number of node hops.
|Description
|Using shortest path with an unbounded pattern will likely result in long execution times.
It is recommended to use an upper limit to the number of node hops in your pattern.
|Category
m|PERFORMANCE
|GQLSTATUS code
m|03N91
|Status description
a|info: unbounded variable length pattern. The provided pattern `{ $pat }` is unbounded.
Shortest path with an unbounded pattern may result in long execution times.
Use an upper limit (e.g. `[*..5]`) on the number of node hops in your pattern.
|Classification
m|PERFORMANCE
|SeverityLevel
m|INFORMATION
|===

.Shortest path with an unbounded pattern
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher, role="noplay"]
----
MATCH p=shortestPath((n)-[*]->(m))
WHERE n <> m
RETURN p
----

Returned GQLSTATUS code::
03N91

Returned status description::
info: unbounded variable length pattern.
The provided pattern `(n)-[\*]->(m)` is unbounded.
Shortest path with an unbounded pattern may result in long execution times.
Use an upper limit (e.g. `[*..5]`) on the number of node hops in your pattern.

Suggestions for improvement::
If you have a big graph, this query might be very slow.
Consider adding an upper limit.
+
[source, cypher, role="noplay"]
----
MATCH p=shortestPath((n)-[*..8]->(m))
WHERE n <> m
RETURN p
----
======
[.include-with-neo4j--code]
======

Query::
+
[source, cypher, role="noplay"]
----
MATCH p=shortestPath((n)-[*]->(m)) RETURN p
----

Description of the returned code::
Using shortest path with an unbounded pattern will likely result in long execution times.
It is recommended to use an upper limit to the number of node hops in your pattern.

Suggestions for improvement::
If you have a big graph, this query might be very slow.
Consider adding an upper limit.
+
[source, cypher, role="noplay"]
----
MATCH p=shortestPath((n)-[*..8]->(m)) RETURN p
----
======
=====

[#_neo_clientnotification_statement_exhaustiveshortestpath]
=== Exhaustive shortest path

This notification is returned when a predicate, given on the shortest path, needs to inspect the whole path before deciding whether it is valid, the shortest path might fall back to the exhaustive search algorithm.
For more information, see link:https://neo4j.com/docs/cypher-manual/current/execution-plans/shortestpath-planning#_shortest_pathadditional_predicate_checks_on_the_paths[Cypher manual -> Shortest path - additional predicate checks on the paths].

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.ExhaustiveShortestPath
|Title
a|Exhaustive shortest path has been planned for your query that means that shortest path graph algorithm might not be used to find the shortest path.
Hence an exhaustive enumeration of all paths might be used in order to find the requested shortest path.
|Description
|Using shortest path with an exhaustive search fallback might cause query slow down since shortest path graph algorithms might not work for this use case.
It is recommended to introduce a `WITH` to separate the `MATCH` containing the shortest path from the existential predicates on that path.
|Category
m|PERFORMANCE
|GQLSTATUS code
m|03N92
|Status description
a|info: exhaustive shortest path.
The query runs with exhaustive shortest path due to the existential predicate(s) `{ $pred_list }`.
It may be possible to use `WITH` to separate the `MATCH` from the existential predicate(s).
|Classification
m|PERFORMANCE
|SeverityLevel
m|INFORMATION
|===

.A query that runs with an exhaustive shortest path
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source, cypher, role="noplay"]
----
MATCH p = shortestPath(()-[*..42]-())
WHERE ANY(n in nodes(p) WHERE n:Label)
RETURN p
----

Returned GQLSTATUS code::
03N92

Returned status description::
info: exhaustive shortest path.
The query runs with exhaustive shortest path due to the existential predicate(s) `ANY(n in nodes(p) WHERE n:Label)`.
It may be possible to use `WITH` to separate the `MATCH` from the existential predicate(s).

Suggestions for improvement::
Separate the predicate by introducing a `WITH` after the `MATCH` clause.
+
[source, cypher, role="noplay"]
----
MATCH p = shortestPath(()-[*..42]-())
WITH p
WHERE ANY(n in nodes(p) WHERE n:Label)
RETURN p
----
======
[.include-with-neo4j--code]
======
Query::
+
[source, cypher, role="noplay"]
----
MATCH p = shortestPath(()-[*..42]-())
WHERE ANY(n in nodes(p) WHERE n:Label)
RETURN p
----

Description of the returned code::
Using shortest path with an exhaustive search fallback might cause query slow down since shortest path graph algorithms might not work for this use case.
It is recommended to introduce a `WITH` to separate the `MATCH` containing the shortest path from the existential predicates on that path.

Suggestions for improvement::
Separate the predicate by introducing a `WITH` after the `MATCH` clause.
+
[source, cypher, role="noplay"]
----
MATCH p = shortestPath(()-[*..42]-())
WITH p
WHERE ANY(n in nodes(p) WHERE n:Label)
RETURN p
----
======
=====

[#_neo_clientnotification_statement_noapplicableindex]
=== No applicable index

This notification is returned when using `LOAD CSV` with a `MATCH` or a `MERGE` clause that matches a non-indexed label.
This may not perform well on large data sets.
Adding an index could improve the query speed.

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.NoApplicableIndex
|Title
a|Adding a schema index may speed up this query.
|Description
|Using `LOAD CSV` followed by a `MATCH` or `MERGE` that matches a non-indexed label will most likely not perform well on large data sets.
Please consider using a schema index.
|Category
m|PERFORMANCE
|GQLSTATUS code
m|03N93
|Status description
a|info: no applicable index.
`LOAD CSV` in combination with `MATCH` or `MERGE` on a label that does not have an index may result in long execution times.
Consider adding an index for label `{ $label }`.
|Classification
m|PERFORMANCE
|SeverityLevel
m|INFORMATION
|===

.`LOAD CSV` with `MATCH` or `MERGE`
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line WITH * MATCH (n:Person{name:line[0]}) RETURN line, n
----

Returned GQLSTATUS code::
03N93

Returned status description::
info: no applicable index.
`LOAD CSV` in combination with `MATCH` or `MERGE` on a label that does not have an index may result in long execution times.
Consider adding an index for label `Person`.

Suggestions for improvement::
Create an index on the label and property you match.
+
[source, cypher, role="noplay"]
----
CREATE INDEX FOR (n:Person) ON (n.name)
----
======
[.include-with-neo4j--code]
======

Query::
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line WITH * MATCH (n:Person{name:line[0]}) RETURN line, n
----

Description of the returned code::
Using `LOAD CSV` followed by a `MATCH` or `MERGE` that matches a non-indexed label will most likely not perform well on large data sets.
Please consider using a schema index.

Suggestions for improvement::
Create an index on the label and property you match.
+
[source, cypher, role="noplay"]
----
CREATE INDEX FOR (n:Person) ON (n.name)
----

======
=====

[#_neo_clientnotification_statement_eageroperator]
=== Eager operator

This notification is returned when the execution plan for a query contains the `Eager` operator.

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.EagerOperator
|Title
a|The execution plan for this query contains the Eager operator, which forces all dependent data to be materialized in main memory before proceeding
|Description
|Using `LOAD CSV` with a large data set in a query where the execution plan contains the Eager operator could potentially consume a lot of memory and is likely to not perform well.
See the Neo4j Manual entry on the Eager operator for more information and hints on how problems could be avoided.
|Category
m|PERFORMANCE
|GQLSTATUS code
m|03N94
|Status description
a|info: eager operator.
The query execution plan contains the `Eager` operator.
`LOAD CSV` in combination with `Eager` can consume a lot of memory.
|Classification
m|PERFORMANCE
|SeverityLevel
m|INFORMATION
|===

.`LOAD CSV` with an Eager operator
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line MATCH (n:Person{name:line[0]}) DELETE n RETURN line
----

Returned GQLSTATUS code::
03N94

Returned status description::
info: eager operator.
The query execution plan contains the `Eager` operator.
`LOAD CSV` in combination with `Eager` can consume a lot of memory.

Suggestions for improvement::
See the link:https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/operators/operators-detail/#query-plan-eager[Cypher Manual -> Eager operator] for more information and hints on how to avoid problems.
In this specific case, the query could be rewritten to the following:
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line
CALL {
    WITH line
    MATCH (n:Person{name:line[0]}) DELETE n
}
RETURN line
----
======
[.include-with-neo4j--code]
======

`LOAD CSV` together with an Eager operator can take up a lot of memory.

Query::
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line MATCH (n:Person{name:line[0]}) DELETE n RETURN line
----

Description of the returned code::
Using `LOAD CSV` with a large data set in a query where the execution plan contains the Eager operator could potentially consume a lot of memory and is likely to not perform well.
See the Neo4j Manual entry on the Eager operator for more information and hints on how problems could be avoided.

Suggestions for improvement::
See the link:https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/operators/operators-detail/#query-plan-eager[Cypher Manual -> Eager operator] for more information and hints on how to avoid problems.
In this specific case, the query could be rewritten to the following:
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line
CALL {
    WITH line
    MATCH (n:Person{name:line[0]}) DELETE n
}
RETURN line
----

======
=====


[#_neo_clientnotification_statement_dynamicproperty]
=== Dynamic property

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.DynamicProperty
|Title
a|Queries using dynamic properties will use neither index seeks nor index scans for those properties
|Description
|Using a dynamic property makes it impossible to use an index lookup for this query (`%s`)
|Category
m|PERFORMANCE
|GQLSTATUS code
m|03N95
|Status description
a|info: dynamic property.
An index exists on label/type(s) `{ $label_list }`.
It is not possible to use indexes for dynamic properties.
Consider using static properties.
|Classification
m|PERFORMANCE
|SeverityLevel
m|INFORMATION
|===

.A dynamic node property key makes it impossible to use indexes
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher]
----
MATCH (n:Person) WHERE n[$prop] IS NOT NULL RETURN n;
----

Returned GQLSTATUS code::
03N95

Returned status description::
info: dynamic property.
An index exists on label/type(s) `Person`.
It is not possible to use indexes for dynamic properties.
Consider using static properties.

Suggestions for improvement::
If there is an index for `(n:Person) ON (n.name)`, it will not be used for the above query because the query is using a dynamic property.
Therefore, if there is an index, it is better to use the constant value.
For example, if `prop` is equal to `name`, the following query would be able to use the index:
+
[source, cypher]
----
MATCH (n:Person) WHERE n.name IS NOT NULL RETURN n;
----

======
[.include-with-neo4j--code]
======

Query::
+
[source, cypher]
----
MATCH (n:Person) WHERE n[$prop] IS NOT NULL RETURN n;
----

Description of the returned code::
Using a dynamic property makes it impossible to use an index lookup for this query (indexed label is: `Person`)

Suggestions for improvement::
If there is an index for `(n:Person) ON (n.name)`, it will not be used for the above query because the query is using a dynamic property.
Therefore, if there is an index, it is better to use the constant value.
For example, if `prop` is equal to `name`, the following query would be able to use the index:
+
[source, cypher]
----
MATCH (n:Person) WHERE n.name IS NOT NULL RETURN n;
----

======
=====

.A dynamic relationship property key makes it impossible to use indexes
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source,cypher]
----
MATCH ()-[r: KNOWS]->() WHERE r[$prop] IS NOT NULL RETURN r
----

Returned GQLSTATUS code::
03N95

Returned status description::
info: dynamic property.
An index exists on label/type(s) `KNOWS`.
It is not possible to use indexes for dynamic properties.
Consider using static properties.

Suggestions for improvement::
Similar to dynamic node properties, use a constant value if possible, especially when there is an index on the relationship property.
For example, if `{ $prop }` is equal to `since`, you can rewrite the query to:
+
[source, cypher]
----
MATCH ()-[r: KNOWS]->() WHERE r.since IS NOT NULL RETURN r
----

======
[.include-with-neo4j--code]
======

Query::
+
[source,cypher]
----
MATCH ()-[r: KNOWS]->() WHERE r[$prop] IS NOT NULL RETURN r
----

Description of the returned code::
Using a dynamic property makes it impossible to use an index lookup for this query (indexed type is: `KNOWS`)

Suggestions for improvement::
Similar to dynamic node properties, use a constant value if possible, especially when there is an index on the relationship property.
For example, if `$prop` is equal to `since`, you can rewrite the query to:
+
[source, cypher]
----
MATCH ()-[r: KNOWS]->() WHERE r.since IS NOT NULL RETURN r
----

======
=====

[#_neo_clientnotification_statement_codegenerationfailed]
=== Failed code generation

The `CodeGenerationFailed` notification is created when it is not possible to generate a code for a query, for example, when the query is too big.
For more information about the specific query, see the stack trace in the _debug.log_ file.

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.CodeGenerationFailed
|Title
a|The database was unable to generate code for the query. A stacktrace can be found in the _debug.log_.
|Description
|The database was unable to generate code for the query. A stacktrace can be found in the debug.log. (method too big)
|Category
m|PERFORMANCE
|GQLSTATUS code
m|03N96
|Status description
a|info: failed code generation.
Failed to generate code, falling back to interpreted $enginetype engine. A stacktrace can be found in the debug.log. Cause: $msg.
|Classification
m|PERFORMANCE
|SeverityLevel
m|INFORMATION
|===

//TO ADD EXAMPLES
//To update the description when the code is spit out

[#_hint_notifications]
== `HINT` notifications

`HINT` notifications are returned by default when the Cypher planner or runtime cannot create a query plan to fulfill a specified hint, for example, `JOIN` or `INDEX`.
This behavior of the Cypher planner or runtime can be changed by setting the configuration link:https://neo4j.com/docs/operations-manual/current/configuration/configuration-settings/#config_dbms.cypher.hints_error[`dbms.cypher.hints_error`] to `true`.
In this case, the query will return an error.

[#_neo_clientnotification_statement_joinhintunfulfillablewarning]
=== Join hint unfulfillable

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.JoinHintUnfulfillableWarning
|Title
a|The database was unable to plan a hinted join.
|Description
|The hinted join was not planned.
This could happen because no generated plan contained the join key,
please try using a different join key or restructure your query. (`%s`)
|Category
m|HINT
|GQLSTATUS code
m|01N30
|Status description
a|warn: join hint unfulfillable. Unable to create a plan with `JOIN ON $var_list`. Try to change the join key(s) or restructure your query.
|Classification
m|HINT
|SeverityLevel
m|WARNING
|===

.Inability to fulfill the hint despite the given `JOIN` hint
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher]
----
MATCH (a:A)
WITH a, 1 AS horizon
OPTIONAL MATCH (a)-[r]->(b:B)
USING JOIN ON a
OPTIONAL MATCH (a)--(c)
RETURN *
----

Returned GQLSTATUS code::
01N30

Returned status description::
warn: joint hint unfulfillable.
Unable to create a plan with `JOIN ON a`.
Try to change the join key(s) or restructure your query.

Suggestions for improvement::
The `JOIN` hint cannot be applied because its specified variable is before the `OPTIONAL MATCH` and, therefore, is already bound.
The only option for this query is to either remove the hint or modify the query to allow it to be used.

======
[.include-with-neo4j--code]
======

Query::
+
[source, cypher]
----
MATCH (a:A)
WITH a, 1 AS horizon
OPTIONAL MATCH (a)-[r]->(b:B)
USING JOIN ON a
OPTIONAL MATCH (a)--(c)
RETURN *
----

Description of the returned code::
The hinted join was not planned.
This could happen because no generated plan contained the join key,
please try using a different join key or restructure your query. (hinted join key identifier is: `a`)

Suggestions for improvement::
The `JOIN` hint cannot be applied because its specified variable is before the `OPTIONAL MATCH` and, therefore, is already bound.
The only option for this query is to either remove the hint or modify the query to allow it to be used.

======
=====


[#_neo_clientnotification_schema_hintedindexnotfound]
=== Hinted index not found

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Schema.HintedIndexNotFound
|Title
a|The request (directly or indirectly) referred to an index that does not exist.
|Description
|The hinted index does not exist, please check the schema (`%s`)
|Category
m|HINT
|GQLSTATUS code
m|01N31
|Status description
a|warn: hinted index not found.
Unable to create a plan with `{ $index_descr }` because the index does not exist.
|Classification
m|HINT
|SeverityLevel
m|WARNING
|===

.Inability to use the label index despite the given index hint
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher]
----
MATCH (a: Label)
USING INDEX a:Label(id)
WHERE a.id = 1
RETURN a
----

Returned GQLSTATUS code::
01N31

Returned status description::
warn: hinted index not found.
Unable to create a plan with `INDEX :Label(id)` because the index does not exist.

Suggestions for improvement::
The hinted index does not exist, make sure the label and property are spelled correctly.
If the spelling is correct, either create the index or remove the hint from the query.
======
[.include-with-neo4j--code]
======

Query::
+
[source, cypher]
----
MATCH (a: Label)
USING INDEX a:Label(id)
WHERE a.id = 1
RETURN a
----

Description of the returned code::
The hinted index does not exist, please check the schema (index is: INDEX FOR (`a`:`Label`) ON (`a`.`id`))

Suggestions for improvement::
The hinted index does not exist, make sure the label and property are spelled correctly.
If the spelling is correct, either create the index or remove the hint from the query.

======
=====

.Inability to use the relationship index despite the given index hint
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source, cypher]
----
MATCH ()-[r:Rel]-()
USING INDEX r:Rel(id)
WHERE r.id = 1
RETURN r
----

Returned GQLSTATUS code::
01N31

Returned status description::
warn: hinted index not found.
Unable to create a plan with `INDEX :Rel(id)` because the index does not exist.

Suggestions for improvement::
The hinted index does not exist, make sure the relationship type and property are spelled correctly.
If the spelling is correct, either create the index or remove the hint from the query.
======
[.include-with-neo4j--code]
======

Query::
+
[source, cypher]
----
MATCH ()-[r:Rel]-()
USING INDEX r:Rel(id)
WHERE r.id = 1
RETURN r
----

Description of the returned code::
The hinted index does not exist, please check the schema (index is: INDEX FOR ()-[`r`:`Rel`]-() ON (`r`.`id`))

Suggestions for improvement::
The hinted index does not exist, make sure the relationship type and property are spelled correctly.
If the spelling is correct, either create the index or remove the hint from the query.

======
=====

[#_unrecognized_notifications]
== `UNRECOGNIZED` notifications

Unrecognized notifications are returned when the query or command mentions entities that are unknown to the system.

[#_neo_clientnotification_database_homedatabasenotfound]
=== Home database not found

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Database.HomeDatabaseNotFound
|Title
a|The request referred to a home database that does not exist.
|Description
|The home database provided does not currently exist in the DBMS.
This command will not take effect until this database is created. (`%s`)
|Category
m|UNRECOGNIZED
|GQLSTATUS code
m|00N50
|Status description
a|note: successful completion - home database not found.
The database `{ $db }` does not exist.
Verify that the spelling is correct or create the database for the command to take effect.
|Classification
m|UNRECOGNIZED
|SeverityLevel
m|INFORMATION
|===

.Setting the `home` database to a database that does not exist
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source,cypher]
----
CREATE USER john SET PASSWORD "secret" SET HOME DATABASE nej4
----

Returned GQLSTATUS code::
00N50

Returned status description::
note: successful completion - home database not found.
The database `ne4j` does not exist.
Verify that the spelling is correct or create the database for the command to take effect.

Suggestions for improvement::
Verify that the home database name is not misspelled.
======
[.include-with-neo4j--code]
======

Query::
+
[source,cypher]
----
CREATE USER john SET PASSWORD "secret" SET HOME DATABASE nej4
----

Description of the returned code::
The home database provided does not currently exist in the DBMS.
This command will not take effect until this database is created. (HOME DATABASE: `nej4`)

Suggestions for improvement::
Verify that the home database name is not misspelled.

======
=====

[#_neo_clientnotification_statement_unknownlabelwarning]
=== Unknown label

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.UnknownLabelWarning
|Title
a|The provided label is not in the database.
|Description
|One of the labels in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (`%s`)
|Category
m|UNRECOGNIZED
|GQLSTATUS code
m|01N50
|Status description
a|warn: unknown label.
The label `{ $label }` does not exist.
Verify that the spelling is correct.
|Classification
m|UNRECOGNIZED
|SeverityLevel
m|WARNING
|===

.Matching on a node with a label that does not exist in the database
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Query::
+
[source,cypher]
----
MATCH (n:Perso) RETURN n
----

Returned GQLSTATUS code::
01N50

Returned status description::
warn: unknown label.
The label `Perso` does not exist.
Verify that the spelling is correct.

Suggestions for improvement::
Verify that the label is not misspelled.
If you plan to create nodes with that label in the future, no change is needed.
======
[.include-with-neo4j--code]
======

Query::
+
[source,cypher]
----
MATCH (n:Perso) RETURN n
----

Description of the returned code::
One of the labels in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing label name is: `Perso`)

Suggestions for improvement::
Verify that the label is not misspelled.
If you plan to create nodes with that label in the future, then no change is needed.

======
=====

[#_neo_clientnotification_statement_unknownrelationshiptypewarning]
=== Unknown relationship type

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning
|Title
a|The provided relationship type is not in the database.
|Description
|One of the relationship types in your query is not available in the database,
make sure you didn't misspell it or that the label is available when you run this statement in your application (`%s`)
|Category
m|UNRECOGNIZED
|GQLSTATUS code
m|01N51
|Status description
a|warn: unknown relationship type.
The relationship type `{ $reltype }` does not exist.
Verify that the spelling is correct.
|Classification
m|UNRECOGNIZED
|SeverityLevel
m|WARNING
|===

.Matching a relationship with a type that does not exist
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (n)-[:NonExistingType]->() RETURN n
----

Returned GQLSTATUS code::
01N51

Returned status description::
warn: unknown relationship type.
The relationship type `NonExistingType` does not exist.
Verify that the spelling is correct.

Suggestions for improvement::
Verify that the relationship type is not misspelled.
If you plan to create relationships of this type in the future, no change is needed.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (n)-[:NonExistingType]->() RETURN n
----

Description of the returned code::
One of the relationship types in your query is not available in the database,
make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: `NonExistingType`)

Suggestions for improvement::
Verify that the relationship type is not misspelled.
If you plan to create relationships of this type in the future, no change is needed.

======
=====

[#_neo_clientnotification_statement_unknownpropertykeywarning]
=== Unknown property key

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.UnknownPropertyKeyWarning
|Title
a|The provided property key is not in the database
|Description
|One of the property names in your query is not available in the database,
make sure you didn't misspell it or that the label is available when you run this statement in your application (`%s`)
|Category
m|UNRECOGNIZED
|GQLSTATUS code
m|01N52
|Status description
a|warn: unknown property key.
The property `{ $propkey }` does not exist.
Verify that the spelling is correct.
|Classification
m|UNRECOGNIZED
|SeverityLevel
m|WARNING
|===

.Matching a property key that does not exist
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (n:Person {nme:”Tom”})
RETURN n
----

Returned GQLSTATUS code::
01N52

Returned status description::
warn: unknown property key.
The property `nme` does not exist.
Verify that the spelling is correct.

Suggestions for improvement::
Verify that the property key is not misspelled.
If you plan to create that property key in the future, no change is needed.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (n:Person {nme:”Tom”})
RETURN n
----

Description of the returned code::
One of the property names in your query is not available in the database,
make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: `nme`)

Suggestions for improvement::
Verify that the property key is not misspelled.
If you plan to create that property key in the future, no change is needed.

======
=====

[#_neo_clientnotification_statement_AggregationSkippedNull]
=== Aggregation skipped null

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.AggregationSkippedNull
|Title
a|The query contains an aggregation function that skips null values.
|Description
|The query contains an aggregation function that skips null values.
|Category
m|UNRECOGNIZED
|GQLSTATUS code
m|01G11
|Status description
a|warn: null value eliminated in set function.
|Classification
m|UNRECOGNIZED
|SeverityLevel
m|WARNING
|===

.Aggregation skipping a NULL value
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
UNWIND [1, NULL, 2] AS i RETURN count(i) AS sum
----

Returned GQLSTATUS code::
01G11

Returned status description::
warn: null value eliminated in set function.
======
[.include-with-neo4j--code]
======
Query::

[source,cypher]
----
UNWIND [1, NULL, 2] AS i RETURN count(i) AS sum
----
Description of the returned code::
The query contains an aggregation function that skips null values.
======
=====

[#_unsupported_notifications]
== `UNSUPPORTED` category

Unsupported notifications are returned when the query or command is trying to use features that are not supported by the current system or using experimental features that should not be used in production.

[#_neo_clientnotification_statement_runtimeunsupportedwarning]
=== Unsupported runtime

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.RuntimeUnsupportedWarning
|Title
a|This query is not supported by the chosen runtime.
|Description
|Selected runtime is unsupported for this query, please use a different runtime instead or fallback to default.
(`%s`)
|Category
m|UNSUPPORTED
|GQLSTATUS code
m|01N40
|Status description
a|warn: unsupported runtime.
The query cannot be executed with `{ $preparser_input1 }`, `{ $preparser_input2 }` is used.
Cause: `{ $msg }`.
|Classification
m|UNSUPPORTED
|SeverityLevel
m|WARNING
|===

.A runtime is not supported by a Cypher command
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
EXPLAIN CYPHER runtime=pipelined SHOW INDEXES YIELD *
----

Returned GQLSTATUS code::
01N40

Returned status description::
warn: unsupported runtime.
The query cannot be executed with `runtime=pipelined`, `runtime=slotted` is used.
Cause: Pipelined does not yet support the plans including `ShowIndexes`, use another runtime.

Suggestions for improvement::
Use a different runtime or remove the runtime option to run the query with the default runtime:
+
[source,cypher]
----
SHOW INDEXES YIELD *
----
======
[.include-with-neo4j--code]
======

Query::
+
[source,cypher]
----
CYPHER runtime=pipelined SHOW INDEXES YIELD *
----

Description of the returned code::
Selected runtime is unsupported for this query, please use a different runtime instead or fallback to default.
(Pipelined does not yet support the plans including `ShowIndexes`, use another runtime.)

Suggestions for improvement::
Use a different runtime or remove the runtime option to run the query with the default runtime:
+
[source,cypher]
----
SHOW INDEXES YIELD *
----

======
=====

[role=label--deprecated-5.14]
[#_neo_clientnotification_statement_runtimeexperimental]
=== RuntimeExperimental

[NOTE]
====
The usage of this notification has been removed since Neo4j 5.14.
====

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.RuntimeExperimental
|Title
a|This feature is experimental and should not be used in production systems.
|Description
|You are using an experimental feature (`%s`)
|Category
m|UNSUPPORTED
|SeverityLevel
m|WARNING
|===

.Use of the parallel runtime
====
Query::
+
[source,cypher]
----
CYPHER runtime=parallel MATCH (n) RETURN (n)
----

Description of the returned code::
You are using an experimental feature (The parallel runtime is experimental and might suffer from instability and potentially correctness issues.)

Suggestions for improvement::
The parallel runtime should not be used in production. Choose another runtime or remove the option to use the default runtime:
+
[source,cypher]
----
MATCH (n) RETURN (n)
----
====

[#_deprecated_notifications]
== `DEPRECATION` notifications

Deprecation notifications contain information about a feature or functionality that has been deprecated.
It is important to change to the new functionality, otherwise, the query might break in a future version.

[#_neo_clientnotification_statement_featuredeprecated]
=== Feature deprecated

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.FeatureDeprecationWarning
|Title
a|This feature is deprecated and will be removed in future versions.
|Descriptions
a|
- The procedure has a deprecated field. (`%s`)
- The function has a deprecated field. (`%s`)
- Creating an entity (`%s`) and referencing that entity in a property definition in the same CREATE is deprecated.
- Merging an entity (`%s`) and referencing that entity in a property definition in the same MERGE is deprecated.
- The Unicode character `%s` is deprecated for unescaped identifiers and will be considered as a whitespace character in the future.
To continue using it, escape the identifier by adding backticks around the identifier `%s`.
- The character with the Unicode representation `%s` is deprecated for unescaped identifiers and will not be supported in the future.
To continue using it, escape the identifier by adding backticks around the identifier `%s`.
- label:new[Valid for Neo4j 5.5-5.25] All subqueries in a UNION [ALL] should have the same ordering for the return columns.
Using differently ordered return items in a UNION [ALL] clause is deprecated and will be removed in a future version.
- Databases and aliases with unescaped `.` are deprecated unless to indicate that they belong to a composite database.
Names containing `.` should be escaped. (`%s`)
|Category
m|DEPRECATION
|GQLSTATUS code
m|01N00
|Status description
a|warn: feature deprecated. $msg
|Classification
m|DEPRECATION
|SeverityLevel
m|WARNING
|===

.Create a database with an unescaped name containing a dot
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo.bar
----

Returned GQLSTATUS code::
01N00

Returned status description::
warn: feature deprecated.
Databases and aliases with unescaped `.` are deprecated unless to indicate that they belong to a composite database. Names containing `.` should be escaped. (Name: foo.bar)

Suggestions for improvement::
If not intended for a composite database, escape the name with the character ```.
+
[source,cypher]
----
CREATE DATABASE `foo.bar`
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo.bar
----

Description of the returned code::
Databases and aliases with unescaped `.` are deprecated unless to indicate that they belong to a composite database.
Names containing `.` should be escaped. (Name: `foo.bar`)

======
=====

.Using differently ordered return items in a `UNION` clause
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
RETURN 'val' as one, 'val' as two
UNION
RETURN 'val' as two, 'val' as one
----

Returned GQLSTATUS code::
01N00

Returned status description::
warn: feature deprecated.
All subqueries in a UNION [ALL] should have the same ordering for the return columns.
Using differently ordered return items in a UNION [ALL] clause is deprecated and will be removed in a future version.

======
=====

[NOTE]
====
Using differently ordered return items in a UNION [ALL] clause is deprecated in versions 5.5 to 5.25.
However, starting from version 5.26, the deprecation has been withdrawn following cost-benefit analysis and valuable user feedback.
====

.Using the Unicode \u0085 in an unescaped identifier
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
RETURN 'val' as one, 'val' as two
UNION
RETURN 'val' as two, 'val' as one
----

Description of the returned code::
All subqueries in a UNION [ALL] should have the same ordering for the return columns.
Using differently ordered return items in a UNION [ALL] clause is deprecated and will be removed in a future version.

Suggestions for improvement::
Use the same order for the return columns in all subqueries combined by a `UNION` clause.

+
[source,cypher]
----
RETURN 'val' as one, 'val' as two
UNION
RETURN 'val' as one, 'val' as two
----

======
=====

.Using the Unicode \u0085 in an unescaped identifier
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
RETURN 1 as my\u0085identifier
----

Returned GQLSTATUS code::
01N00

Returned status description::
warn: feature deprecated.
The Unicode character `\u0085` is deprecated for unescaped identifiers and will be considered as a whitespace character in the future.
To continue using it, escape the identifier by adding backticks around the identifier `my\u0085identifier`.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
RETURN 1 as my\u0085identifier
----
Description of the returned code::
The Unicode character `\u0085` is deprecated for unescaped identifiers and will be considered as a whitespace character in the future. To continue using it, escape the identifier by adding backticks around the identifier `my\u0085identifier`.

======
=====

[#_deprecated-feature-with-replacement]
=== Feature deprecated with a replacement

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.FeatureDeprecationWarning
|Title
a|This feature is deprecated and will be removed in future versions.
|Descriptions
a|
- The semantics of using colon in the separation of alternative relationship types will change in a future version. (`%s`)
- The use of nodes or relationships for setting properties is deprecated and will be removed in a future version.
Please use properties() instead.
- The use of shortestPath and allShortestPaths with fixed length relationships is deprecated and will be removed in a future version.
Please use a path with a length of 1 [r*1..1] instead or a Match with a limit.
- The query used a deprecated function. (`%s`)
- The query used a deprecated procedure. (`%s`)
- The query used a deprecated runtime option. (`%s`)
- The `TextIndexProvider.DESCRIPTOR.name()` provider for text indexes is deprecated and will be removed in a future version.
Please use `TrigramIndexProvider.DESCRIPTOR.name()` instead.
|Category
m|DEPRECATION
|GQLSTATUS code
m|01N01
|Status description
a|warn: feature deprecated with replacement.
`{ $thing1 }` is deprecated.
It is replaced by `{ $thing2 }`.
|Classification
m|DEPRECATION
|SeverityLevel
m|WARNING
|===

.Colon after the vertical bar `|:` in a relationship pattern
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (a)-[:A|:B|:C]-() RETURN *
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`:A|:B|:C` is deprecated.
It is replaced by `:A|B|C`.

Suggestions for improvement::
Remove the colon inside the relationship type expression.
+
[source,cypher]
----
MATCH (a)-[:A|B|C]-() RETURN *
----

======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (a)-[:A|:B|:C]-() RETURN *
----

Description of the returned code::
The semantics of using colon in the separation of alternative relationship types will change in a future version. (Please use ':A|B|C' instead)

Suggestions for improvement::
Remove the colon inside the relationship type expression.
+
[source,cypher]
----
MATCH (a)-[:A|B|C]-() RETURN *
----

======
=====

.Setting properties using a node
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (a)-[]-(b)
SET a = b
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`SET a = b` is deprecated.
It is replaced by `SET a = properties(b)`.

Suggestions for improvement::
Use the `properties()` function to get all properties from `b`.
+
[source,cypher]
----
MATCH (a)-[]-(b)
SET a = properties(b)
----

======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (a)-[]-(b)
SET a = b
----

Description of the returned code::
The use of nodes or relationships for setting properties is deprecated and will be removed in a future version.
Please use `properties()` instead.

Suggestions for improvement::
Use the `properties()` function to get all properties from `b`.
+
[source,cypher]
----
MATCH (a)-[]-(b)
SET a = properties(b)
----

======
=====


.Setting properties using a relationship
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (a)-[r]-(b)
SET a += r
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`SET a += r` is deprecated.
It is replaced by `SET a += properties(r)`.

Suggestions for improvement::
Use the `properties()` function to get all properties from `r`.
+
[source,cypher]
----
MATCH (a)-[r]-(b)
SET a += properties(r)
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (a)-[r]-(b)
SET a += r
----

Description of the returned code::
The use of nodes or relationships for setting properties is deprecated and will be removed in a future version.
Please use `properties()` instead.

Suggestions for improvement::
Use the `properties()` function to get all properties from `r`.
+
[source,cypher]
----
MATCH (a)-[r]-(b)
SET a += properties(r)
----

======
=====


.Shortest path with a fixed relationship length
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (a:Start), shortestPath((a)-[r]->()) RETURN a
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`shortestPath\((a)-[r]->())` is deprecated.
It is replaced by `shortestPath\((n)-[r*1..1]->(m))`.

Suggestions for improvement::
If the relationship length is fixed, there is no reason to search for the shortest path.
Instead, you can rewrite it to the following:
+
[source,cypher]
----
MATCH (a: Start)-[r]->(b: End) RETURN b LIMIT 1
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (a:Start), shortestPath((a)-[r]->()) RETURN a
----

Description of the returned code::
The use of `shortestPath` and `allShortestPaths` with fixed length relationships is deprecated and will be removed in a future version.
Please use a path with a length of `1 [r*1..1]` instead or a `Match` with a `limit`.

Suggestions for improvement::
If the relationship length is fixed, there is no reason to search for the shortest path.
Instead, you can rewrite it to the following:
+
[source,cypher]
----
MATCH (a: Start)-[r]->(b: End) RETURN b LIMIT 1
----

======
=====

.Using a deprecated runtime option
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CYPHER runtime = interpreted MATCH (n) RETURN n
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`runtime=interpreted` is deprecated.
It is replaced by `runtime=slotted`.

Suggestions for improvement::
Runtime `interpreted` is deprecated and another runtime is used instead.
Alternatively, you can remove the runtime option to use the default runtime.
+
[source,cypher]
----
MATCH (n) RETURN n
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CYPHER runtime = interpreted MATCH (n) RETURN n
----

Description of the returned code::
The query used a deprecated runtime option. (`'runtime=interpreted'` is deprecated, please use `'runtime=slotted'` instead)

Suggestions for improvement::
Runtime `interpreted` is deprecated and another runtime is used instead.
Alternatively, you can remove the runtime option to use the default runtime.
+
[source,cypher]
----
MATCH (n) RETURN n
----

======
=====

.Using the `text-1.0` index provider when creating a text index
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CREATE TEXT INDEX FOR (n:Label) ON (n.prop) OPTIONS {indexProvider : 'text-1.0'}
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`text-1.0` is deprecated.
It is replaced by `text-2.0`.

Suggestions for improvement::
Update the option `indexProvider` with the value `text-2.0`.
+
[source,cypher]
----
CREATE TEXT INDEX FOR (n:Label) ON (n.prop) OPTIONS {indexProvider : 'text-2.0'}
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CREATE TEXT INDEX FOR (n:Label) ON (n.prop) OPTIONS {indexProvider : 'text-1.0'}
----

Description of the returned code::
The `text-1.0` provider for text indexes is deprecated and will be removed in a future version.
Please use `text-2.0` instead.

Suggestions for improvement::
Update the option `indexProvider` with the value `text-2.0`.
+
[source,cypher]
----
CREATE TEXT INDEX FOR (n:Label) ON (n.prop) OPTIONS {indexProvider : 'text-2.0'}
----

======
=====

.Using a renamed or a deprecated procedure
[.tabbed-example]
=====
[.include-with-GQLSTATUS-deprecated-with-replacement]
======
[source,cypher]
----
CALL cdc.query
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`cdc.query` is deprecated.
It is replaced by `db.cdc.query`.

======
[.include-with-GQLSTATUS-deprecated-without-replacement]
======
[source,cypher]
----
CALL unsupported.dbms.shutdown
----

Returned GQLSTATUS code::
01N02

Returned status description::
warn: feature deprecated without replacement.
`unsupported.dbms.shutdown` is deprecated and will be removed without a replacement.
======
[.include-with-neo4j--code]
======

[source,cypher]
----
CALL unsupported.dbms.shutdown
----

Description of the returned code::
The query used a deprecated procedure: `'unsupported.dbms.shutdown'`.

Suggestions for improvement::
Remove the use of the deprecated procedure.
If there is a suggested replacement, update to use the replacement instead.

======
=====

.Using id() function
[.tabbed-example]
=====
[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH (a)
RETURN id(a)
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`id` is deprecated.
It is replaced by `elementId()`.

Suggestions for improvement::
Use the function `elementId()` instead.
+
[source,cypher]
----
MATCH (a)
RETURN elementId(a)
----
======
[.include-with-GQLSTATUS-deprecated-without-replacement]
======
Query::
+
[source,cypher]
----
MATCH (a)
RETURN id(a)
----

Returned GQLSTATUS code::
01N02

Returned status description::
warn: feature deprecated without replacement.
`id` is deprecated and will be removed without a replacement.
======
[.include-with-neo4j--code]
======

Query::
+
[source,cypher]
----
MATCH (a)
RETURN id(a)
----

Description of the returned code::
The query used a deprecated function: `id`.

Suggestions for improvement::
Use the function `elementId()` instead.
+
[source,cypher]
----
MATCH (a)
RETURN elementId(a)
----
======
=====

.Using an unescaped variable named 'where' in a node pattern
[.tabbed-example]
=====
[.include-with-neo4j-code]
======

Query::
+
[source,cypher]
----
MATCH (where {p: 5})
RETURN where
----

Description of the returned code::
'(where {p: 5})' is deprecated. It is replaced by '(++`where`++ {p: 5})'.

Suggestions for improvement::
To continue using variables with this name, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (`where` {p: 5})
RETURN `where`.p
----
======

[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH (where {p: 5})
RETURN where
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`(where {p: 5})` is deprecated.
It is replaced by `(++`where`++ {p: 5})`.

Suggestions for improvement::
To continue using variables with this name, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (`where` {p: 5})
RETURN `where`.p
----
======
=====

.Using an unescaped variable named 'where' in a relationship pattern
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH ()-[where {p: 5}]->()
RETURN where
----

Description of the returned code::
'-[where {p: 5}]-' is deprecated. It is replaced by '-[++`where`++ {p: 5}]-'.

Suggestions for improvement::
To continue using variables with this name, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH ()-[`where` {p: 5}]->()
RETURN `where`.p
----
======

[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH ()-[where {p: 5}]->()
RETURN where
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`-[where {p: 5}]-` is deprecated.
It is replaced by `-[++`where`++ {p: 5}]-`.

Suggestions for improvement::
To continue using variables with this name, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH ()-[`where` {p: 5}]->()
RETURN `where`.p
----
======
=====

.Using an unparenthesized label expression predicate as the right-hand side operand of `+`
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH m, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + m:A
----

Description of the returned code::
'... + m:A' is deprecated. It is replaced by '... + (m:A)'.

Suggestions for improvement::
Parenthesize the label expression predicate on the right-hand side of `+`:
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH m, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + (m:A)
----
======

[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH m, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + m:A
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`... + m:A` is deprecated.
It is replaced by `... + (m:A)`.

Suggestions for improvement::
Parenthesize the label expression predicate on the right-hand side of `+`:
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH m, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + (m:A)
----
======
=====

.Using an unparenthesized label expression predicate as the right-hand side operand of `+`
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH r, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + r:C|D
----

Description of the returned code::
'... + r:C|D' is deprecated. It is replaced by '... + (r:C|D)'.

Suggestions for improvement::
Parenthesize the label expression predicate on the right-hand side of `+`:
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH r, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + (r:C|D)
----
======

[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH r, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + r:C|D
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`... + r:C|D` is deprecated.
It is replaced by `... + (r:C|D)`.

Suggestions for improvement::
Parenthesize the label expression predicate on the right-hand side of `+`:
+
[source,cypher]
----
MATCH (n)-[r]->(m)
WITH r, n.truthCodes AS listOfBooleans
RETURN listOfBooleans + (r:C|D)
----
======
=====

.Using an unescaped variable named `is` as a `WHEN` operand in a simple `CASE` expression
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH (n)
WITH n, n.internationalStandard AS is
RETURN CASE n
  WHEN is :: INTEGER THEN "ISO/IEC" + is
  ELSE is
END AS standardsName
----

Description of the returned code::
'WHEN is :: INTEGER' is deprecated. It is replaced by 'WHEN ++`is`++ :: INTEGER'.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (n)
WITH n, n.internationalStandard AS `is`
RETURN CASE n
  WHEN `is` :: INTEGER THEN "ISO/IEC" + `is`
  ELSE `is`
END AS standardsName
----
======
[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH (n)
WITH n, n.internationalStandard AS is
RETURN CASE n
  WHEN is :: INTEGER THEN "ISO/IEC" + is
  ELSE is
END AS standardsName
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`WHEN is pass:[::] INTEGER` is deprecated.
It is replaced by `WHEN ++`is`++ pass:[::] INTEGER`.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (n)
WITH n, n.internationalStandard AS `is`
RETURN CASE n
  WHEN `is` :: INTEGER THEN "ISO/IEC" + `is`
  ELSE `is`
END AS standardsName
----
======
=====

.Using an unescaped variable named `contains` in addition operations within a `WHEN` operand in a simple `CASE` expression
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(relationships(p)) AS contains
RETURN CASE size(nodes(p))
  WHEN contains + 1 THEN "okay"
  ELSE "not okay"
END AS check
----

Description of the returned code::
'WHEN contains + 1 INTEGER' is deprecated. It is replaced by 'WHEN ++`contains`++ + 1 INTEGER'.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(relationships(p)) AS `contains`
RETURN CASE size(nodes(p))
  WHEN `contains` + 1 THEN "okay"
  ELSE "not okay"
END AS check
----
======
[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(relationships(p)) AS contains
RETURN CASE size(nodes(p))
  WHEN contains + 1 THEN "okay"
  ELSE "not okay"
END AS check
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`WHEN contains + 1 INTEGER` is deprecated.
It is replaced by `WHEN ++`contains`++ + 1 INTEGER`.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(relationships(p)) AS `contains`
RETURN CASE size(nodes(p))
  WHEN `contains` + 1 THEN "okay"
  ELSE "not okay"
END AS check
----
======
=====

.Using an unescaped variable named `contains` in subtraction operations within a `WHEN` operand in a simple `CASE` expression
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(nodes(p)) AS contains
RETURN CASE size(relationships(p))
  WHEN contains - 1 THEN "okay"
  ELSE "not okay"
END AS check
----

Description of the returned code::

'WHEN contains - 1 INTEGER' is deprecated. It is replaced by 'WHEN ++`contains`++ - 1 INTEGER'.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(nodes(p)) AS `contains`
RETURN CASE size(relationships(p))
  WHEN `contains` - 1 THEN "okay"
  ELSE "not okay"
END AS check
----
======
[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(nodes(p)) AS contains
RETURN CASE size(relationships(p))
  WHEN contains - 1 THEN "okay"
  ELSE "not okay"
END AS check
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`WHEN contains - 1 INTEGER` is deprecated.
It is replaced by `WHEN ++`contains`++ - 1 INTEGER`.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH p = (:A)-[:HAS]->(:B)
WITH p, size(nodes(p)) AS `contains`
RETURN CASE size(relationships(p))
  WHEN `contains` - 1 THEN "okay"
  ELSE "not okay"
END AS check
----
======
=====

.Using the `[]` operator on an unescaped variable named `in` within a `WHEN` operand in a simple `CASE` expression
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH (c:Client)-[:MAKES]->(t:Transaction)
WITH t, c.ibanNumbers AS in
RETURN CASE t.ibanNumber
  WHEN in[0] THEN "used main account"
  ELSE "used different account"
END AS check
----

Description of the returned code::

'WHEN in[0] INTEGER' is deprecated. It is replaced by 'WHEN ++`in`++[0] INTEGER'.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (c:Client)-[:MAKES]->(t:Transaction)
WITH t, c.ibanNumbers AS `in`
RETURN CASE t.ibanNumber
  WHEN `in`[0] THEN "used main account"
  ELSE "used different account"
END AS check
----
======
[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH (c:Client)-[:MAKES]->(t:Transaction)
WITH t, c.ibanNumbers AS in
RETURN CASE t.ibanNumber
  WHEN in[0] THEN "used main account"
  ELSE "used different account"
END AS check
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`WHEN in[0] INTEGER` is deprecated.
It is replaced by `WHEN ++`in`++[0] INTEGER`.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (c:Client)-[:MAKES]->(t:Transaction)
WITH t, c.ibanNumbers AS `in`
RETURN CASE t.ibanNumber
  WHEN `in`[0] THEN "used main account"
  ELSE "used different account"
END AS check
----
======
=====

.Using the `[]` operator on an unescaped variable named `in` within a `WHEN` operand in a simple `CASE` expression
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Query::
+
[source,cypher]
----
MATCH (in:Client)-[:MAKES]->(t:Transaction)
RETURN CASE t.ibanNumber
  WHEN in["mainAccount"] THEN "used main account"
  ELSE "used different account"
END AS check
----

Description of the returned code::

'WHEN in["mainAccount"] INTEGER' is deprecated. It is replaced by 'WHEN ++`in`++["mainAccount"] INTEGER'.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (in:Client)-[:MAKES]->(t:Transaction)
RETURN CASE t.ibanNumber
  WHEN `in`["mainAccount"] THEN "used main account"
  ELSE "used different account"
END AS check
----
======
[.include-with-GQLSTATUS-deprecated-with-replacement]
======
Query::
+
[source,cypher]
----
MATCH (in:Client)-[:MAKES]->(t:Transaction)
RETURN CASE t.ibanNumber
  WHEN in["mainAccount"] THEN "used main account"
  ELSE "used different account"
END AS check
----

Returned GQLSTATUS code::
01N01

Returned status description::
warn: feature deprecated with replacement.
`WHEN in["mainAccount"] INTEGER` is deprecated.
It is replaced by `WHEN ++`in`++["mainAccount"] INTEGER`.

Suggestions for improvement::
To continue using variables with this name in simple `CASE` expressions, use backticks to escape the variable name:
+
[source,cypher]
----
MATCH (in:Client)-[:MAKES]->(t:Transaction)
RETURN CASE t.ibanNumber
  WHEN `in`["mainAccount"] THEN "used main account"
  ELSE "used different account"
END AS check
----
======
=====

[#_deprecated-notifications-without-replacement]
=== Deprecated features without a future replacement

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.FeatureDeprecationWarning
|Title
a|This feature is deprecated and will be removed in future versions.
|Descriptions
a|
- The Cypher query option `connectComponentsPlanner` is deprecated and will be removed without a replacement.
The product's default behavior of using a cost-based IDP search algorithm when combining sub-plans will be kept.
For more information, see Cypher Manual -> Cypher planner.
- The query used a deprecated function%s
- The query used a deprecated procedure%s
|Category
m|DEPRECATION
|GQLSTATUS code
m|01N02
|Status description
a|warn: feature deprecated without replacement.
`{ $thing }` is deprecated and will be removed without a replacement.
|Classification
m|DEPRECATION
|SeverityLevel
m|WARNING
|===

.Using Cypher query option `connectComponentsPlanner`
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CYPHER connectComponentsPlanner=greedy MATCH (a), (b) RETURN *
----

Returned GQLSTATUS code::
01N02

Returned status description::
warn: feature deprecated without replacement.
`connectComponentsPlanner` is deprecated and will be removed without a replacement.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CYPHER connectComponentsPlanner=greedy MATCH (a), (b) RETURN *
----
Description of the returned code::
The Cypher query option `connectComponentsPlanner` is deprecated and will be removed without a replacement.
The product's default behavior of using a cost-based IDP search algorithm when combining sub-plans will be kept.
For more information, see link:https://neo4j.com/docs/cypher-manual/current/query-tuning/query-options/#cypher-planner[Cypher manual -> Cypher planner].

======
=====

[[_deprecated-procedure-result-column]]
=== Procedure field deprecated

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.FeatureDeprecationWarning
|Title
a|This feature is deprecated and will be removed in future versions.
|Description
a|The query used a deprecated field from a procedure. (`%s`)
|Category
m|DEPRECATION
|GQLSTATUS code
m|01N03
|Status description
a|warn: procedure field deprecated.
`{ $field }` for procedure `{ $proc }` is deprecated.
|Classification
m|DEPRECATION
|SeverityLevel
m|WARNING
|===

[#_neo_clientnotification_request_]
=== Feature deprecated with replacement - DeprecatedFormat

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Request.DeprecatedFormat
|Title
a|The client made a request for a format which has been deprecated.
|Description
|The requested format has been deprecated. (`%s`)
|Category
m|DEPRECATION
|GQLSTATUS code
m|01N01
|Status description
a|warn: feature deprecated with replacement.
`{ $thing1 }` is deprecated.
It is replaced by `{ $thing2 }`.
|Classification
m|DEPRECATION
|SeverityLevel
m|WARNING
|===

[#_security_notifications]
== `SECURITY` category

Security notifications indicate that the result of the query or command might have a potential security issue.
Verify that this is the intended behavior of your query or command.

[#_neo_clientnotification_security_commandhasnoeffect]
=== Role or privilege not assigned

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Security.CommandHasNoEffect
|Title
a|`<command>` has no effect.*
|Descriptions
a|
- The user does not have the role. See Status Codes documentation for more information.
- The role does not have the privilege. See Status Codes documentation for more information.
|Category
m|SECURITY
|GQLSTATUS code
m|00N71
|Status description
|note: successful completion - role or privilege not assigned.
`{ $cmd }` has no effect.
The role or privilege is not assigned.
|Classification
m|SECURITY
|SeverityLevel
m|INFORMATION
|===

*_``<command>`` and `cmd` could be either the full command given by the user or a subset of the given command._


.Revoking a role from a user who does not have that role
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
REVOKE ROLE admin, reader FROM jane
----

Returned GQLSTATUS code::
00N71

Returned status description::
note: successful completion - role or privilege not assigned.
`REVOKE ROLE reader FROM jane` has no effect.
The role or privilege is not assigned.

Suggestions for improvement::
Verify that this is the intended role and user.
======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REVOKE ROLE admin, reader FROM jane
----

Title of the returned code::
`REVOKE ROLE reader FROM jane` has no effect.

Description of the returned code::
The user does not have the role. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and user.
======
=====

.Revoking a privilege from a role that does not have that privilege
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Command::
+
[source, cypher]
----
REVOKE WRITE ON GRAPH * FROM reader
----

Returned GQLSTATUS code::
00N71

Returned status description::
note: successful completion - role or privilege not assigned.
`REVOKE DENY WRITE ON GRAPH * FROM reader` has no effect.
The role or privilege is not assigned.

Suggestions for improvement::
Verify that this is the intended privilege and role.

======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REVOKE WRITE ON GRAPH * FROM reader
----

Title of the returned code::
`REVOKE DENY WRITE ON GRAPH * FROM reader` has no effect.

Description of the returned code::
The role does not have the privilege. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended privilege and role.
======
=====


[#_neo_clientnotification_security_roleorprivilegealreadyassigned]
=== Role or privilege already assigned

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Security.CommandHasNoEffect
|Title
a|`<command>` has no effect.*
|Descriptions
a|
- The user already has the role. See Status Codes documentation for more information.
- The role already has the privilege. See Status Codes documentation for more information.
|Category
m|SECURITY
|GQLSTATUS code
m|00N70
|Status description
|note: successful completion - role or privilege already assigned.
`{ $cmd }` has no effect.
The role or privilege is already assigned.
|Classification
m|SECURITY
|SeverityLevel
m|INFORMATION
|===

*_``<command>`` and `cmd` could be either the full command given by the user or a subset of the given command._


.Granting a role to a user who already has that role
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source,cypher]
----
GRANT ROLE admin TO john
----

Returned GQLSTATUS code::
00N70

Returned status description::
note: successful completion - role or privilege already assigned.
`GRANT ROLE admin TO john` has no effect.
The role or privilege is already assigned.

Suggestions for improvement::
Verify that this is the intended role and user.

======
[.include-with-neo4j--code]
======
Command::
+
[source,cypher]
----
GRANT ROLE admin TO john
----
Title of the returned code::
`GRANT ROLE admin TO john` has no effect.

Description of the returned code::
The user already has the role. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and user.

======
=====


.Granting or denying a privilege to a role that already has that privilege
// This command returns 2 notifications, one for NODES and one for RELATIONSHIPS.
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
GRANT TRAVERSE ON GRAPH * TO reader
----

Returned GQLSTATUS code::
00N70

Returned status description::
note: successful completion - role or privilege already assigned.
`GRANT TRAVERSE ON GRAPH * TO reader` has no effect.
The role or privilege is already assigned.

Suggestions for improvement::
Verify that this is the intended privilege and role.
======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
GRANT TRAVERSE ON GRAPH * TO reader
----

Title of the returned code::
`GRANT TRAVERSE ON GRAPH * NODE * TO reader` has no effect.

Description of the returned code::
The role already has the privilege. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended privilege and role.

======
=====



[#_neo_clientnotification_security_impossiblerevokecommand]
=== Impossible revoke command

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Security.ImpossibleRevokeCommand
|Title
a|`<command>` has no effect.*
|Description
|Role does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.
|Category
m|SECURITY
|GQLSTATUS code
m|01N70
|Status description
a|warn: impossible revoke command. `cmd` has no effect. $msg
Make sure nothing is misspelled.
This notification will become an error in a future major version.
|Classification
m|SECURITY
|SeverityLevel
m|WARNING
|===

*_``<command>`` and `cmd` could be either the full command given by the user or a subset of the given command._

.Revoking a non-existing role from a user
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
REVOKE ROLE manager, reader FROM jane
----

Returned GQLSTATUS code::
01N70

Returned status description::
warn: impossible revoke command.
`REVOKE ROLE manager FROM jane` has no effect.
Role does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.

Suggestions for improvement::
Verify that this is the intended role and that it is spelled correctly.
======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REVOKE ROLE manager, reader FROM jane
----

Title of the returned code::
`REVOKE ROLE manager FROM jane` has no effect.

Description of the returned code::
Role does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and that it is spelled correctly.
======
=====

.Revoking a role from a non-existing user
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Command::
+
[source, cypher]
----
REVOKE ROLE reader FROM alice
----

Returned GQLSTATUS code::
01N70

Returned status description::
warn: impossible revoke command.
`REVOKE ROLE reader FROM alice` has no effect.
User does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.
o
Suggestions for improvement::
Verify that this is the intended user and that it is spelled correctly.
======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REVOKE ROLE reader FROM alice
----

Title of the returned code::
`REVOKE ROLE reader FROM alice` has no effect.

Description of the returned code::
User does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.

Suggestions for improvement::
Verify that this is the intended user and that it is spelled correctly.
======
=====


.Revoking a privilege from a non-existing role
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Command::
+
[source, cypher]
----
REVOKE GRANT WRITE ON GRAPH * FROM manager
----

Returned GQLSTATUS code::
01N70

Returned status description::
warn: impossible revoke command.
`REVOKE GRANT WRITE ON GRAPH * FROM manager` has no effect.
Role does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.

Suggestions for improvement::
Verify that this is the intended role and that it is spelled correctly.
======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REVOKE GRANT WRITE ON GRAPH * FROM manager
----

Title of the returned code::
`REVOKE GRANT WRITE ON GRAPH * FROM manager` has no effect.

Description of the returned code::
Role does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and that it is spelled correctly.
======
=====

.Revoking a privilege on a non-existing graph from a role
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
REVOKE GRANT WRITE ON GRAPH neo3j FROM editor
----

Returned GQLSTATUS code::
01N70

Returned status description::
warn: impossible revoke command.
`REVOKE GRANT WRITE ON GRAPH neo3j FROM editor` has no effect.
Database `neo3j` does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.

Suggestions for improvement::
Verify that this is the intended graph and that it is spelled correctly.
======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REVOKE GRANT WRITE ON GRAPH neo3j FROM editor
----

Title of the returned code::
`REVOKE GRANT WRITE ON GRAPH neo3j FROM editor` has no effect.

Description of the returned code::
Database `neo3j` does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended graph and that it is spelled correctly.
======
=====

.Revoking a privilege on a non-existing database from a role
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
REVOKE GRANT ACCESS ON DATABASE neo3j FROM editor
----

Returned GQLSTATUS code::
01N70

Returned status description::
warn: impossible revoke command.
`REVOKE GRANT ACCESS ON DATABASE neo3j FROM editor` has no effect.
Database `neo3j` does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.

Suggestions for improvement::
Verify that this is the intended database and that it is spelled correctly.

======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REVOKE GRANT ACCESS ON DATABASE neo3j FROM editor
----

Title of the returned code::
`REVOKE GRANT ACCESS ON DATABASE neo3j FROM editor` has no effect.

Description of the returned code::
Database `neo3j` does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended database and that it is spelled correctly.
======
=====


.Revoking a privilege from a role with wildcard graph parameter
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Parameter::
+
[source, javascript]
----
{
    "graph": "*"
}
----
Command::
+
[source, cypher]
----
REVOKE GRANT CREATE ON GRAPH $graph FROM PUBLIC
----

Returned GQLSTATUS code::
01N70

Returned status description::
warn: impossible revoke command.
`REVOKE GRANT CREATE ON GRAPH $graph FROM PUBLIC` has no effect.
Database `*` does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.

Suggestions for improvement::
Use `GRAPH *` without the parameter to revoke the privilege on all graphs.


======
[.include-with-neo4j--code]
======
Parameter::
+
[source, javascript]
----
{
    "graph": "*"
}
----
Command::
+
[source, cypher]
----
REVOKE GRANT CREATE ON GRAPH $graph FROM PUBLIC
----

Title of the returned code::
`REVOKE GRANT CREATE ON GRAPH $graph FROM PUBLIC` has no effect.

Description of the returned code::
Parameterized database and graph names do not support wildcards.
Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Use `GRAPH *` without the parameter to revoke the privilege on all graphs.
======
=====

.Revoking a privilege from a role with a wildcard database parameter
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======

Parameter::
+
[source, javascript]
----
{
    "database": "*"
}
----
Command::
+
[source, cypher]
----
REVOKE GRANT ACCESS ON DATABASE $database FROM PUBLIC
----

Returned GQLSTATUS code::
01N70

Returned status description::
warn: impossible revoke command.
`REVOKE GRANT ACCESS ON DATABASE $database FROM PUBLIC` has no effect.
Database `*` does not exist.
Make sure nothing is misspelled.
This notification will become an error in a future major version.

Suggestions for improvement::
Use `DATABASE *` without the parameter to revoke the privilege on all databases.

======
[.include-with-neo4j--code]
======
Parameter::
+
[source, javascript]
----
{
    "database": "*"
}
----
Command::
+
[source, cypher]
----
REVOKE GRANT ACCESS ON DATABASE $database FROM PUBLIC
----

Title of the returned code::
`REVOKE GRANT ACCESS ON DATABASE $database FROM PUBLIC` has no effect.

Description of the returned code::
Parameterized database and graph names do not support wildcards.
Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Use `DATABASE *` without the parameter to revoke the privilege on all databases.
======
=====

[#_neo_clientnotification_security_authprovidernotdefined]
=== AuthProviderNotDefined

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Security.AuthProviderNotDefined
|Title
a|The auth provider is not defined.
|Description
a|The auth provider `{ $provider }` is not defined in the configuration.
Verify that the spelling is correct or define `{ $provider }` in the configuration.
|Category
m|SECURITY
|GQLSTATUS code
m|00N72
|Status description
a|note: successful completion - undefined auth provider.
The auth provider { $auth } is not defined in the configuration.
Verify that the spelling is correct or define { $auth } in the configuration.
|Classification
m|SECURITY
|SeverityLevel
m|INFORMATION
|===


.Create a user with an auth provider that is not defined in the configuration
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Command::
+
[source, cypher]
----
CREATE USER foo SET AUTH 'unknownProvider' { SET ID 'idString' }
----

Description of the returned code::
The auth provider `unknownProvider` is not defined in the configuration.
Verify that the spelling is correct or define `unknownProvider` in the configuration.

Suggestions for improvement::
Make sure that the given provider is correct, or replace it if not.
If it is correct, make sure to add it as a known auth provider in one or both of `dbms.security.authentication_providers` and `dbms.security.authorization_providers`.
======
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
CREATE USER foo SET AUTH 'unknownProvider' { SET ID 'idString' }
----

Returned GQLSTATUS code::
00N72

Returned status description::
note: successful completion - undefined auth provider.
The auth provider `unknownProvider` is not defined in the configuration.
Verify that the spelling is correct or define `unknownProvider` in the configuration.

Suggestions for improvement::
Make sure that the given provider is correct, or replace it if not.
If it is correct, make sure to add it as a known auth provider in one or both of `dbms.security.authentication_providers` and `dbms.security.authorization_providers`.
======
=====

.Alter a user to add an auth provider that is not defined in the configuration
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Command::
+
[source, cypher]
----
ALTER USER foo SET AUTH 'unknownProvider' { SET ID 'idString' }
----

Description of the returned code::
The auth provider `unknownProvider` is not defined in the configuration.
Verify that the spelling is correct or define `unknownProvider` in the configuration.

Suggestions for improvement::
Make sure that the given provider is correct, or replace it if not.
If it is correct, make sure to add it as a known auth provider in one or both of `dbms.security.authentication_providers` and `dbms.security.authorization_providers`.
======

[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
ALTER USER foo SET AUTH 'unknownProvider' { SET ID 'idString' }
----

Returned GQLSTATUS code::
00N72

Returned status description::
note: successful completion - undefined auth provider.
The auth provider `unknownProvider` is not defined in the configuration.
Verify that the spelling is correct or define `unknownProvider` in the configuration.

Suggestions for improvement::
Make sure that the given provider is correct, or replace it if not.
If it is correct, make sure to add it as a known auth provider in one or both of `dbms.security.authentication_providers` and `dbms.security.authorization_providers`.
======
=====


[#_neo_clientnotification_security_externalauthnotenabled]
=== ExternalAuthNotEnabled

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Security.ExternalAuthNotEnabled
|Title
a|External auth for user is not enabled.
|Description
a|Use setting `dbms.security.require_local_user` to enable external auth.
|Category
m|SECURITY
|GQLSTATUS code
m|01N71
|Status description
|warn: external auth disabled.
Use the setting 'dbms.security.require_local_user' to enable external auth.
|Classification
m|SECURITY
|SeverityLevel
m|WARNING
|===

.Create a user with an external auth provider when linked users are not enabled
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Command::
+
[source, cypher]
----
CREATE USER foo SET AUTH 'exampleProvider' { SET ID 'idString' }
----

Suggestions for improvement::
Enable linked users through the `dbms.security.require_local_user` setting.
Until enabled, the new external auth will be ignored, and current external auth behaviors will continue to apply.
======
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
CREATE USER foo SET AUTH 'exampleProvider' { SET ID 'idString' }
----

Returned GQLSTATUS code::
01N71

Returned status description::
warn: external auth disabled.
Use the setting 'dbms.security.require_local_user' to enable external auth.

Suggestions for improvement::
Enable linked users through the `dbms.security.require_local_user` setting.
Until enabled, the new external auth will be ignored, and current external auth behaviors will continue to apply.

======
=====

.Alter a user to add an external auth provider when linked users are not enabled
[.tabbed-example]
=====
[.include-with-neo4j-code]
======
Command::
+
[source, cypher]
----
ALTER USER foo SET AUTH 'exampleProvider' { SET ID 'idString' }
----

Suggestions for improvement::
Enable linked users through the `dbms.security.require_local_user` setting.
Until enabled, the new external auth will be ignored, and current external auth behaviors will continue to apply.
======

[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
ALTER USER foo SET AUTH 'exampleProvider' { SET ID 'idString' }
----

Returned GQLSTATUS code::
01N71

Returned status description::
warn: external auth disabled.
Use the setting 'dbms.security.require_local_user' to enable external auth.

Suggestions for improvement::
Enable linked users through the `dbms.security.require_local_user` setting.
Until enabled, the new external auth will be ignored, and current external auth behaviors will continue to apply.

======
=====


[#_topology_notifications]
== `TOPOLOGY` category

Topology notifications provide additional information related to managing databases and servers.

[#_neo_clientnotification_cluster_serveralreadyenabled]
=== Server already enabled


.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.ServerAlreadyEnabled
|Title
a| `<command>` has no effect.
|Description
a|Server `%s` is already enabled.
Verify that this is the intended server.
|Category
m|TOPOLOGY
|GQLSTATUS code
m|00N80
|Status description
a|note: successful completion - server already enabled.
`ENABLE SERVER` has no effect.
Server `{ $server }` is already enabled.
Verify that this is the intended server.
|Classification
m|TOPOLOGY
|SeverityLevel
m|INFORMATION
|===

.Enabling an already enabled server
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
ENABLE SERVER "123e4567-e89b-12d3-a456-426614174000"
----

Returned GQLSTATUS code::
00N80

Returned status description::
note: successful completion - server already enabled.
`ENABLE SERVER` has no effect.
Server `123e4567-e89b-12d3-a456-426614174000` is already enabled.
Verify that this is the intended server.

======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
ENABLE SERVER "123e4567-e89b-12d3-a456-426614174000"
----

Description of the returned code::
Server `123e4567-e89b-12d3-a456-426614174000` is already enabled.
Verify that this is the intended server.

======
=====

[#_neo_clientnotification_cluster_serveralreadycordoned]
=== Server already cordoned

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.ServerAlreadyCordoned
|Title
a| `<command>` has no effect.
|Description
a|Server `%s` is already cordoned.
Verify that this is the intended server.
|Category
m|TOPOLOGY
|GQLSTATUS code
m|00N81
|Status description
a|note: successful completion - server already cordoned.
`CORDON SERVER` has no effect.
Server `{ $server }` is already cordoned.
Verify that this is the intended server.
|Classification
m|TOPOLOGY
|SeverityLevel
m|INFORMATION
|===

.Cordoning an already cordoned server
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
CORDON SERVER "123e4567-e89b-12d3-a456-426614174000"
----

Returned GQLSTATUS code::
00N81

Returned status description::
note: successful completion - server already cordoned.
`CORDON SERVER` has no effect.
Server `123e4567-e89b-12d3-a456-426614174000` is already cordoned.
Verify that this is the intended server.

======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
CORDON SERVER "123e4567-e89b-12d3-a456-426614174000"
----

Description of the returned code::
Server `123e4567-e89b-12d3-a456-426614174000` is already cordoned.
Verify that this is the intended server.

======
=====

[#_neo_clientnotification_cluster_nodatabasesreallocated]
=== No databases reallocated

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.NoDatabasesReallocated
|Title
a| `<command>` has no effect.
|Description
a| No databases were reallocated. No better allocation is currently possible.
|Category
m|TOPOLOGY
|GQLSTATUS code
m|00N82
|Status description
a|note: successful completion - no databases reallocated.
`REALLOCATE DATABASES` has no effect.
No databases were reallocated.
No better allocation is currently possible.
|Classification
m|TOPOLOGY
|SeverityLevel
m|INFORMATION
|===

.Reallocating databases resulted in no allocation changes
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
REALLOCATE DATABASES
----

Returned GQLSTATUS code::
00N82

Returned status description::
note: successful completion - no databases reallocated.
`REALLOCATE DATABASES` has no effect.
No databases were reallocated.
No better allocation is currently possible.

Example scenarios::
**Scenario 1:** The cluster is already balanced.
For example, when there are three servers, each hosting databases `foo` and `bar`, meaning all databases are allocated to all servers.
+

**Scenario 2:** The cluster appears unbalanced, but server constraints prevent you from moving to a better, more balanced, allocation.
For example, assuming server 1 hosts databases `foo` and `bar`, server 2 hosts only `foo`, and server 3 hosts no databases.
Then, a better allocation would move `foo` from server 1 to server 3, but if server 3 has the constraint `deniedDatabases:['foo']}`, then the cluster is already balanced subject to this constraint.
======
[.include-with-neo4j--code]
======
Command::
+
[source, cypher]
----
REALLOCATE DATABASES
----

Description of the returned code::
No databases were reallocated. No better allocation is currently possible.


Example scenarios::
**Scenario 1:** The cluster is already balanced.
For example, when there are three servers, each hosting databases `foo` and `bar`, meaning all databases are allocated to all servers.
+

**Scenario 2:** The cluster appears unbalanced, but server constraints prevent you from moving to a better, more balanced, allocation.
For example, assuming server 1 hosts databases `foo` and `bar`, server 2 hosts only `foo`, and server 3 hosts no databases.
Then, a better allocation would move `foo` from server 1 to server 3, but if server 3 has the constraint `deniedDatabases:['foo']}`, then the cluster is already balanced subject to this constraint.
======
=====

[#_neo_clientnotification_cluster_cordonedserversexistedduringallocation]
=== Cordoned servers existed during allocation

This notification is returned when a Cypher administration command triggers an allocation decision and some of the servers are cordoned.
For example, `CREATE DATABASE`, `ALTER DATABASE`, `DEALLOCATE DATABASES FROM SERVER[S]`, and `ALTER DATABASE` return this notification. However, `REALLOCATE DATABASES` requires that there are no cordoned servers and, therefore, does not return it.

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.CordonedServersExistedDuringAllocation
|Title
a| Cordoned servers existed when making an allocation decision.
|Description
a| Server(s) `%s` are cordoned. This can impact allocation decisions.
|Category
m|TOPOLOGY
|GQLSTATUS code
m|00N83
|Status description
a|note: successful completion - cordoned servers existed during allocation.
Cordoned servers existed when making an allocation decision.
Server(s) `{ $server_list }` are cordoned.
This can impact allocation decisions.
|Classification
m|TOPOLOGY
|SeverityLevel
m|INFORMATION
|===

.Cordoned servers existed during an allocation decision
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
The example assumes that you have a cluster with three servers, of which server `123e4567-e89b-12d3-a456-426614174000` is cordoned using the `dbms.cluster.cordonServer` procedure. Then the below command will return this notification.

Command::
+
[source, cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES
----

Returned GQLSTATUS code::
00N83

Returned status description::
note: successful completion - cordoned servers existed during allocation.
Cordoned servers existed when making an allocation decision.
Server(s) `123e4567-e89b-12d3-a456-426614174000` are cordoned.
This can impact allocation decisions.
======
[.include-with-neo4j--code]
======
The example assumes that you have a cluster with three servers, of which server `123e4567-e89b-12d3-a456-426614174000` is cordoned using the `dbms.cluster.cordonServer` procedure. Then the below command will return this notification.

Command::
+
[source, cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES
----

Description of the returned code::
Server(s) `123e4567-e89b-12d3-a456-426614174000` are cordoned. This can impact allocation decisions.
======
=====


[#_neo_clientnotification_cluster_requestedtopologymatchedcurrenttopology]
=== Requested topology matched current topology

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.RequestedTopologyMatchedCurrentTopology
|Title
a| `<command>` has no effect.
|Description
a|The requested topology matched the current topology.
No allocations were changed.
|Category
m|TOPOLOGY
|GQLSTATUS code
m|00N84
|Status description
a|note: successful completion - requested topology matched current topology.
`ALTER DATABASE` has no effect.
The requested topology matched the current topology.
No allocations were changed.
|Classification
m|TOPOLOGY
|SeverityLevel
m|INFORMATION
|===

.Requested topology matched current topology
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
The example assumes that you have a cluster with three servers and a database `foo` with a topology of two primaries and one secondary.

Command::
+
[source, cypher]
----
ALTER DATABASE foo SET TOPOLOGY 2 PRIMARIES 1 SECONDARY
----

Returned GQLSTATUS code::
00N84

Returned status description::
note: successful completion - requested topology matched current topology.
`ALTER DATABASE` has no effect.
The requested topology matched the current topology.
No allocations were changed.

======
[.include-with-neo4j--code]
======
The example assumes that you have a cluster with three servers and a database `foo` with a topology of two primaries and one secondary.

Command::
+
[source, cypher]
----
ALTER DATABASE foo SET TOPOLOGY 2 PRIMARIES 1 SECONDARY
----

Description of the returned code::
The requested topology matched the current topology. No allocations were changed.
======
=====

[#_schema_notifications]
== `SCHEMA` category

Schema notifications provide additional information related to indexes and constraints.

[#_neo_clientnotification_schema_indexorconstraintalreadyexists]
=== Index or constraint already exists

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists
|Title
a|`<command>` has no effect.
|Description
a|`<conflicting>` already exists.
|Description
a|`%s` already exists.
|Category
m|SCHEMA
|GQLSTATUS code
m|00NA0
|Status description
a|note: successful completion - index or constraint already exists.
`{ $cmd }` has no effect.
`{ $index_constr_pat }` already exists.
|SeverityLevel
m|INFORMATION
|===

*_``<command>`` and `cmd` could be either the full command given by the user or a subset of the given command._

.Creating an index when an equivalent index already exists
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Given a range index on `(:Label \{property})` named `existingRangeIndex`.

Command::
+
[source, cypher]
----
CREATE INDEX labelProperyRangeIndex IF NOT EXISTS FOR (n:Label) ON (n.property)
----

Returned GQLSTATUS code::
00NA0

Returned status description::
note: successful completion - index or constraint already exists.
`CREATE RANGE INDEX labelProperyRangeIndex IF NOT EXISTS FOR (e:Label) ON (e.property)` has no effect.
`RANGE INDEX existingRangeIndex FOR (e:Label) ON (e.property)` already exists.

======
[.include-with-neo4j--code]
======
Given a range index on `(:Label \{property})` named `existingRangeIndex`.

Command::
+
[source, cypher]
----
CREATE INDEX labelProperyRangeIndex IF NOT EXISTS FOR (n:Label) ON (n.property)
----

Title of the returned code::
`CREATE RANGE INDEX labelProperyRangeIndex IF NOT EXISTS FOR (e:Label) ON (e.property)` has no effect.

Full description of the returned code::
`RANGE INDEX existingRangeIndex FOR (e:Label) ON (e.property)` already exists.

======
=====

.Creating an index when another unrelated index using that name already exists
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Given a range index on `(:Label \{property})` named `myIndex`.

Command::
+
[source, cypher]
----
CREATE TEXT INDEX myIndex IF NOT EXISTS FOR ()-[r:REL_TYPE]-() ON (r.property)
----

Returned GQLSTATUS code::
00NA0

Returned status description::
note: successful completion - index or constraint already exists.
`CREATE TEXT INDEX myIndex IF NOT EXISTS FOR ()-[e:REL_TYPE]-() ON (e.property)` has no effect.
`RANGE INDEX myIndex FOR (e:Label) ON (e.property)` already exists.

Suggestions for improvement::
Choose a different name for the new index and try again.
+
[source, cypher]
----
CREATE TEXT INDEX myIndex2 IF NOT EXISTS FOR ()-[r:REL_TYPE]-() ON (r.property)
----

======
[.include-with-neo4j--code]
======
Given a range index on `(:Label \{property})` named `myIndex`.

Command::
+
[source, cypher]
----
CREATE TEXT INDEX myIndex IF NOT EXISTS FOR ()-[r:REL_TYPE]-() ON (r.property)
----

Title of the returned code::
`CREATE TEXT INDEX myIndex IF NOT EXISTS FOR ()-[e:REL_TYPE]-() ON (e.property)` has no effect.

Full description of the returned code::
`RANGE INDEX myIndex FOR (e:Label) ON (e.property)` already exists.

Suggestions for improvement::
Choose a different name for the new index and try again.
+
[source, cypher]
----
CREATE TEXT INDEX myIndex2 IF NOT EXISTS FOR ()-[r:REL_TYPE]-() ON (r.property)
----

======
=====

.Creating a constraint when an identical constraint already exists
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Given a node key constraint on `(:Label \{property})` named `nodeKeyLabelPropertyConstraint`.

Command::
+
[source, cypher]
----
CREATE CONSTRAINT nodeKeyLabelPropertyConstraint IF NOT EXISTS FOR (n:Label) REQUIRE (n.property) IS NODE KEY
----

Returned GQLSTATUS code::
00NA0

Returned status description::
note: successful completion - index or constraint already exists.
`CREATE CONSTRAINT nodeKeyLabelPropertyConstraint IF NOT EXISTS FOR (e:Label) REQUIRE (e.property) IS NODE KEY` has no effect.
`CONSTRAINT nodeKeyLabelPropertyConstraint FOR (e:Label) REQUIRE (e.property) IS NODE KEY` already exists.

======
[.include-with-neo4j--code]
======
Given a node key constraint on `(:Label \{property})` named `nodeKeyLabelPropertyConstraint`.

Command::
+
[source, cypher]
----
CREATE CONSTRAINT nodeKeyLabelPropertyConstraint IF NOT EXISTS FOR (n:Label) REQUIRE (n.property) IS NODE KEY
----

Title of the returned code::
`CREATE CONSTRAINT nodeKeyLabelPropertyConstraint IF NOT EXISTS FOR (e:Label) REQUIRE (e.property) IS NODE KEY` has no effect.

Full description of the returned code::
`CONSTRAINT nodeKeyLabelPropertyConstraint FOR (e:Label) REQUIRE (e.property) IS NODE KEY` already exists.

======
=====


.Creating a constraint when another unrelated constraint using that name already exists
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Given a node key constraint on `(:Label \{property})` named `myConstraint`.

Command::
+
[source, cypher]
----
CREATE CONSTRAINT myConstraint IF NOT EXISTS FOR (n:Label2) REQUIRE (n.property2) IS NOT NULL
----

Returned GQLSTATUS code::
00NA0

Returned status description::
note: successful completion - index or constraint already exists.
`CREATE CONSTRAINT myConstraint IF NOT EXISTS FOR (e:Label2) REQUIRE (e.property2) IS NOT NULL` has no effect.
`CONSTRAINT myConstraint FOR (e:Label) REQUIRE (e.property) IS NODE KEY` already exists.

Suggestions for improvement::
Choose a different name for the new constraint and try again.
+
[source, cypher]
----
CREATE CONSTRAINT myConstraint2 IF NOT EXISTS FOR (n:Label2) REQUIRE (n.property2) IS NOT NULL
----

======
[.include-with-neo4j--code]
======
Given a node key constraint on `(:Label \{property})` named `myConstraint`.

Command::
+
[source, cypher]
----
CREATE CONSTRAINT myConstraint IF NOT EXISTS FOR (n:Label2) REQUIRE (n.property2) IS NOT NULL
----

Title of the returned code::
`CREATE CONSTRAINT myConstraint IF NOT EXISTS FOR (e:Label2) REQUIRE (e.property2) IS NOT NULL` has no effect.

Full description of the returned code::
`CONSTRAINT myConstraint FOR (e:Label) REQUIRE (e.property) IS NODE KEY` already exists.

Suggestions for improvement::
Choose a different name for the new constraint and try again.
+
[source, cypher]
----
CREATE CONSTRAINT myConstraint2 IF NOT EXISTS FOR (n:Label2) REQUIRE (n.property2) IS NOT NULL
----

======
=====

[#_neo_clientnotification_schema_indexorconstraintdoesnotexist]
=== Index or constraint does not exist

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Schema.IndexOrConstraintDoesNotExist
|Title
a|`<command>` has no effect.
|Description
a|`%s` does not exist.
|Category
m|SCHEMA
|GQLSTATUS code
m|00NA1
|Status description
a|note: successful completion - index or constraint does not exist.
`{ $cmd }` has no effect.
`{ $index_constr_name }` does not exist.
|SeverityLevel
m|INFORMATION
|===

.Attempting to drop a non-existing index
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
DROP INDEX nonExistingIndex IF EXISTS
----

Returned GQLSTATUS code::
00NA1

Returned status description::
note: successful completion - index or constraint does not exist.
`DROP INDEX nonExistingIndex IF EXISTS` has no effect.
`nonExistingIndex` does not exist.

Suggestions for improvement::
Verify that this is the intended index and that it is spelled correctly.

======
[.include-with-neo4j--code]
======

Command::
+
[source, cypher]
----
DROP INDEX nonExistingIndex IF EXISTS
----

Title of the returned code::
`DROP INDEX nonExistingIndex IF EXISTS` has no effect.

Full description of the returned code::
`nonExistingIndex` does not exist.

Suggestions for improvement::
Verify that this is the intended index and that it is spelled correctly.

======
=====

.Attempting to drop a non-existing constraint
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Command::
+
[source, cypher]
----
DROP CONSTRAINT nonExistingConstraint IF EXISTS
----

Returned GQLSTATUS code::
00NA1

Returned status description::
note: successful completion - index or constraint does not exist.
`DROP CONSTRAINT nonExistingConstraint IF EXISTS` has no effect.
`nonExistingConstraint` does not exist.

Suggestions for improvement::
Verify that this is the intended constraint and that it is spelled correctly.

======
[.include-with-neo4j--code]
======

Command::
+
[source, cypher]
----
DROP CONSTRAINT nonExistingConstraint IF EXISTS
----

Title of the returned code::
`DROP CONSTRAINT nonExistingConstraint IF EXISTS` has no effect.

Full description of the returned code::
`nonExistingConstraint` does not exist.

Suggestions for improvement::
Verify that this is the intended constraint and that it is spelled correctly.

======
=====

[#_generic]
== `GENERIC` notifications

`GENERIC` notification codes do not belong to any wider category and do not have any connection to each other.

[#_neo_clientnotification_statement_subqueryvariableshadowing]
=== Subquery variable shadowing

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.SubqueryVariableShadowing
|Title
a|Variable in subquery is shadowing a variable with the same name from the outer scope.
|Description
|Variable in subquery is shadowing a variable with the same name from the outer scope.
If you want to use that variable instead, it must be imported into the subquery using importing WITH clause. (`%s`)
|Category
m|GENERIC
|GQLSTATUS code
m|03N60
|Status description
a|info: subquery variable shadowing.
The variable `{ $var }` in the subquery uses the same name as a variable from the outer query.
Use `WITH $var` in the subquery to import the one from the outer scope unless you want it to be a new variable.
|Classification
m|GENERIC
|SeverityLevel
m|INFORMATION
|===

.Shadowing of a variable from the outer scope
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (n)
CALL {
  MATCH (n)--(m)
  RETURN m
}
RETURN *
----

Returned GQLSTATUS code::
03N60

Returned status description::
info: subquery variable shadowing.
The variable `n` in the subquery uses the same name as a variable from the outer query.
Use `WITH n` in the subquery to import the one from the outer scope unless you want it to be a new variable.

Suggestions for improvement::
If the intended behavior of the query is for the variable in the subquery to be a new variable, then nothing needs to be done.
If the intended behavior is to use the variable from the outer query, it needs to be imported to the subquery using the `WITH` clause.
+
[source,cypher]
----
MATCH (n)
CALL {
  WITH n
  MATCH (n)--(m)
  RETURN m
}
RETURN *
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (n)
CALL {
  MATCH (n)--(m)
  RETURN m
}
RETURN *
----

Description of the returned code::
Variable in subquery is shadowing a variable with the same name from the outer scope.
If you want to use that variable instead, it must be imported into the subquery using importing `WITH` clause. (the shadowing variable is: `n`)

Suggestions for improvement::
If the intended behavior of the query is for the variable in the subquery to be a new variable, then nothing needs to be done.
If the intended behavior is to use the variable from the outer query, it needs to be imported to the subquery using the `WITH` clause.
+
[source,cypher]
----
MATCH (n)
CALL {
  WITH n
  MATCH (n)--(m)
  RETURN m
}
RETURN *
----
======
=====

[#_neo_clientnotification_statement_redundantoptionalprocedure]
=== Redundant optional procedure

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.RedundantOptionalProcedure
|Title
a|The use of `OPTIONAL` is redundant when the procedure calls a void procedure.
|Description
|The use of `OPTIONAL` is redundant as `CALL %s` is a void procedure.
|Category
m|GENERIC
|GQLSTATUS code
m|03N61
|Status description
a|info: redundant optional procedure. The use of `OPTIONAL` is redundant as `CALL %s` is a void procedure.
|Classification
m|GENERIC
|SeverityLevel
m|INFORMATION
|===

.Redundant use of `OPTIONAL` in a procedure call
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
OPTIONAL CALL db.createLabel("A")
----
Returned GQLSTATUS code::
03N61

Returned status description::
info: redundant optional procedure. The use of `OPTIONAL` is redundant as `CALL db.createLabel` is a void procedure.

Suggestions for improvement::
If the intended behavior of the query is to use a void procedure, the `OPTIONAL` keyword can be removed without impacting the query.
+
[source,cypher]
----
CALL db.createLabel("A")
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
OPTIONAL CALL db.createLabel("A")
----

Description of the returned code::
The use of `OPTIONAL` is redundant as `CALL db.createLabel` is a void procedure.

Suggestions for improvement::
If the intended behavior of the query is to use a void procedure, the `OPTIONAL` keyword can be removed without impacting the query.
+
[source,cypher]
----
CALL db.createLabel("A")
----
======
=====

[#_neo_clientnotification_statement_redundantoptionalsubquery]
=== Redundant optional subquery

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.RedundantOptionalSubquery
|Title
a|The use of `OPTIONAL` is redundant when `CALL` is a unit subquery.
|Description
|The use of `OPTIONAL` is redundant as `CALL` is a unit subquery.
|Category
m|GENERIC
|GQLSTATUS code
m|03N62
|Status description
a|info: redundant optional subquery. The use of `OPTIONAL` is redundant as `CALL` is a unit subquery.
|Classification
m|GENERIC
|SeverityLevel
m|INFORMATION
|===

.Redundant use of `OPTIONAL` in a `CALL` subquery
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
UNWIND [1, 2, 3] AS x
OPTIONAL CALL (x) {
   CREATE({i:x})
}
----

Returned GQLSTATUS code::
03N62

Description of the returned code::
info: redundant optional subquery. The use of `OPTIONAL` is redundant as `CALL` is a unit subquery.

Suggestions for improvement::
If the intended behavior of the query is for the subquery not to return any values, the `OPTIONAL` keyword can be removed without impacting the query.
+
[source,cypher]
----
UNWIND [1, 2, 3] AS x
CALL (x) {
   CREATE({i:x})
}
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
UNWIND [1, 2, 3] AS x
OPTIONAL CALL (x) {
   CREATE({i:x})
}
----

Description of the returned code::
Optional is redundant in the case of a unit subquery. The use of `OPTIONAL` on unit subqueries have no effect and can be removed.

Suggestions for improvement::
If the intended behavior of the query is for the subquery not to return any values, the `OPTIONAL` keyword can be removed without impacting the query.
+
[source,cypher]
----
UNWIND [1, 2, 3] AS x
CALL (x) {
   CREATE({i:x})
}
----
======
=====

[#_neo_clientnotification_statement_parameternotprovided]
=== Parameter missing

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.ParameterNotProvided
|Title
a|The statement refers to a parameter that was not provided in the request.
|Description
|Did not supply query with enough parameters.
The produced query plan will not be cached and is not executable without EXPLAIN. (`%s`)
|Category
m|GENERIC
|GQLSTATUS code
m|01N60
|Status description
a|warn: parameter missing.
The query plan cannot be cached and is not executable without `EXPLAIN` due to the undefined parameter(s) `{ $param_list }`.
Provide the parameter(s).
|Classification
m|GENERIC
|SeverityLevel
m|WARNING
|===


.Using an `EXPLAIN` query with parameters without providing them
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
EXPLAIN WITH $param as param
RETURN param
----

Returned GQLSTATUS code::
01N60

Returned status description::
warn: parameter missing.
The query plan cannot be cached and is not executable without `EXPLAIN` due to the undefined parameter(s) `{ $param }`.
Provide the parameter(s).

Suggestions for improvement::
Provide the parameter to be able to cache the plan.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
EXPLAIN WITH $param as param
RETURN param
----

Description of the returned code::
Did not supply query with enough parameters.
The produced query plan will not be cached and is not executable without `EXPLAIN`. (Missing parameters: `param`)

Suggestions for improvement::
Provide the parameter to be able to cache the plan.

======
=====


[#_neo_clientnotification_procedure_procedurewarning]
=== Procedure or function execution warning

.Notification details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Procedure.ProcedureWarning
|Title
a|The query used a procedure that generated a warning.
|Description
|The query used a procedure that generated a warning. (`%s`)
|Category
m|GENERIC
|GQLSTATUS code
m|01N62
|Status description
a|warn: procedure execution warning.
The procedure `{ $proc }` generates the warning `{ $msg }`.
|Classification
m|GENERIC
|SeverityLevel
m|WARNING
|===


[role=label--new-5.4]
[#_neo_clientnotification_statement_unsatisfiablerelationshiptypeexpression]
=== Unsatisfiable relationship type expression

When matching on a relationship type expression that can never be satisfied, for example asking for zero, more than one or contradictory types.

.Notification category details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.UnsatisfiableRelationshipTypeExpression
|Title
a|The query contains a relationship type expression that cannot be satisfied.
|Description
|Relationship type expression cannot possibly be satisfied. (`%s`)
|Category
m|GENERIC
|GQLSTATUS code
m|01N61
|Status description
a|warn: unsatisfiable relationship type expression.
The expression `{ $label_expr }` cannot be satisfied because relationships must have exactly one type.
|Classification
m|GENERIC
|SeverityLevel
m|WARNING
|===


.Matching on a relationship type expression that can never be satisfied
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH ()-[r:R1&R2]->() RETURN r
----

Returned GQLSTATUS code::
01N61

Returned status description::
warn: unsatisfiable relationship type expression.
The expression `R1&R2` cannot be satisfied because relationships must have exactly one type.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH ()-[r:R1&R2]->() RETURN r
----
Description of the returned code::
Relationship type expression cannot possibly be satisfied. (`R1&R2` can never be fulfilled by any relationship. Relationships must have exactly one type.)
======
=====

[role=label--new-5.5]
[#_neo_clientnotification_statement_repeatedrelationshipreference]
=== Repeated relationship reference

.Notification category details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Statement.RepeatedRelationshipReference
|Title
a|The query returns no results because a relationship variable is bound more than once.
|Description
a|
- A relationship is referenced more than once in the query, which leads to no results because relationships must not occur more than once in each result. (`%s`)
- A variable-length relationship variable is bound more than once, which leads to no results because relationships must not occur more than once in each result. (`%s`)
|Category
m|GENERIC
|GQLSTATUS code
m|01N63
|Status description
a|
warn: repeated relationship reference. `{ $var }` is repeated in `{ $pat }`, which leads to no results.
|Classification
m|GENERIC
|SeverityLevel
m|WARNING
|===


.Binding a relationship variable more than once
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH (:A)-[r]->(), ()-[r]->(:B) RETURN r
----

Returned GQLSTATUS code::
01N63

Returned status description::
warn: repeated relationship reference.
`r` is repeated in `(:A)-[r]->(), ()-[r]->(:B)`, which leads to no results.

Suggestions for improvement::
Use one pattern to match all relationships that start with a node with the label `A` and end with a node with the label `B`:
+
[source, cypher, role="noplay"]
----
MATCH (:A)-[r]->(:B) RETURN r
----
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH (:A)-[r]->(), ()-[r]->(:B) RETURN r
----
Description of the returned code::
A relationship is referenced more than once in the query, which leads to no results because relationships must not occur more than once in each result. (Relationship `r` was repeated)

Suggestions for improvement::
Use one pattern to match all relationships that start with a node with the label `A` and end with a node with the label `B`:
+
[source, cypher, role="noplay"]
----
MATCH (:A)-[r]->(:B) RETURN r
----
======
=====

.Binding a variable-length relationship variable more than once (when run on version 5.6 or newer)
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
MATCH ()-[r*]->()<-[r*]-() RETURN count(*) AS count
----

Returned GQLSTATUS code::
01N63

Returned status description::
warn: repeated relationship reference.
`r` is repeated in `()-[r*]->()<-[r*]-()`, which leads to no results.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
MATCH ()-[r*]->()<-[r*]-() RETURN count(*) AS count
----
Description of the returned code::
A variable-length relationship variable is bound more than once, which leads to no results because relationships must not occur more than once in each result. (Relationship r was repeated)
======
=====

[role=label--new-2025.01 label--Cypher25]
[#_neo_clientnotification_cluster_servercaughtup]
=== WAIT Server caught up

.Notification category details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.ServerCaughtUp
|Title
a|Server has caught up.
|Description
a|Server `(%s)` at address `(%s)` has caught up.
|Category
m|GENERIC
|GQLSTATUS code
m|03N85
|Status description
a|
info: server has caught up. Server `${ name }` at address `${ address }` has caught up.
|Classification
m|GENERIC
|SeverityLevel
m|INFORMATION
|===


.Successful completion of a `WAIT` command with two servers
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----

One notification is returned for each server in the cluster:

Returned GQLSTATUS code::
03N85

Returned status description::
info: server has caught up. Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Returned GQLSTATUS code::
03N85

Returned status description::
info: server has caught up. Server `ServerId\{0e020000}` at address `localhost:20026` has caught up.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----
One notification is returned for each server in the cluster:

Description of the returned code::
Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Description of the returned code::
Server `ServerId\{0e020000}` at address `localhost:20026` has caught up.
======
=====

[role=label--new-2025.01 label--Cypher25]
[#_neo_clientnotification_cluster_serverfailed]
=== WAIT Server failed

.Notification category details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.ServerFailed
|Title
a|Server failed.
|Description
a|Server `(%s)` at address `(%s)` failed: (%s)
|Category
m|GENERIC
|GQLSTATUS code
m|01N80
|Status description
a|
warn: server failed. Server `${ name }` at address `${ address }` failed: `${ message }`
|Classification
m|GENERIC
|SeverityLevel
m|WARNING
|===


.One out of two servers failed during `WAIT` command
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----

One notification is returned for each server in the cluster:

Returned GQLSTATUS code::
03N85

Returned status description::
info: server has caught up. Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Returned GQLSTATUS code::
01N80

Returned status description::
warn: server failed. Server `ServerId\{0e020000}` at address `localhost:20026` failed: Caught up but has failure for DatabaseId{0db00002[foo]} Failure: java.nio.file.FileAlreadyExistsException: <...>

Suggestions for improvement::
Investigate the failing server using the provided message.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----
One notification is returned for each server in the cluster:

Description of the returned code::
Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Description of the returned code::
Server `ServerId\{0e020000}` at address `localhost:20026` failed: Caught up but has failure for DatabaseId{0db00002[foo]} Failure: java.nio.file.FileAlreadyExistsException: <...>

Suggestions for improvement::
Investigate the failing server using the provided message.
======
=====

[role=label--new-2025.01 label--Cypher25]
[#_neo_clientnotification_cluster_servercatchingup]
=== WAIT Server catching up

.Notification category details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.ServerCachingUp
|Title
a|Server is still catching up.
|Description
a|Server `(%s)` at address `(%s)` is still catching up.
|Category
m|GENERIC
|GQLSTATUS code
m|01N81
|Status description
a|
warn: server is catching up. Server `${ name }` at address `${ address }` is still catching up.
|Classification
m|GENERIC
|SeverityLevel
m|WARNING
|===


.One out of two servers is still catching up during `WAIT` command
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----

One notification is returned for each server in the cluster:

Returned GQLSTATUS code::
03N85

Returned status description::
info: server has caught up. Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Returned GQLSTATUS code::
01N81

Returned status description::
warn: server is catching up. Server `ServerId\{0e020000}` at address `localhost:20026` is still catching up.

Suggestions for improvement::
This behaviour indicates that one of the servers is lagging behind. Investigate the server and network for performance issues or increase the wait timeout.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----
One notification is returned for each server in the cluster:

Description of the returned code::
Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Description of the returned code::
Server `ServerId\{0e020000}` at address `localhost:20026` is still catching up.

Suggestions for improvement::
This behaviour indicates that one of the servers is lagging behind. Investigate the server and network for performance issues or increase the wait timeout.
======
=====

[role=label--new-2025.01 label--Cypher25]
[#_neo_clientnotification_cluster_serverunavailable]
=== WAIT Server not available

.Notification category details
[cols="<1s,<4"]
|===
|Neo4j  code
m|Neo.ClientNotification.Cluster.ServerNotAvailable
|Title
a|Server is not available.
|Description
a|Server `(%s)` at address `(%s)` is not available.
|Category
m|GENERIC
|GQLSTATUS code
m|01N82
|Status description
a|
warn: server is not available. Server `${ name }` at address `${ address }` is not available.
|Classification
m|GENERIC
|SeverityLevel
m|WARNING
|===


.One out of two servers is not available during `WAIT` command
[.tabbed-example]
=====
[.include-with-GQLSTATUS-code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----

One notification is returned for each server in the cluster:

Returned GQLSTATUS code::
03N85

Returned status description::
info: server has caught up. Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Returned GQLSTATUS code::
01N82

Returned status description::
warn: server is not available. Server `ServerId\{0e020000}` at address `localhost:20026` is not available.

Suggestions for improvement::
Investigate the server to determine why it is not available.
======
[.include-with-neo4j--code]
======
Query::
+
[source,cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES WAIT
----
One notification is returned for each server in the cluster:

Description of the returned code::
Server `ServerId\{0e010000}` at address `localhost:20025` has caught up.

Description of the returned code::
Server `ServerId\{0e020000}` at address `localhost:20026` is not available.

Suggestions for improvement::
Investigate the server to determine why it is not available.
======
=====
