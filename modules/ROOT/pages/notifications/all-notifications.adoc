:description: This section describes the notifications that Neo4j can return, grouped by category, and an example of when they can occur.

[[listOfNnotifications]]
= List of all notification codes

The following are all Neo4j notifications, grouped by category, when they are returned, and an example of improvement.

* <<_performance_notifications, `PERFORMANCE` category>>
* <<_hint_notifications, `HINT` category>>
* <<_unrecognized_notifications, `UNRECOGNIZED` category>>
* <<_unsupported_notifications, `UNSUPPORTED` category>>
* <<_deprecated_notifications, `DEPRECATION` category>>
* <<_security_notifications, `SECURITY` category>>
* <<_topology_notifications, `TOPOLOGY` category>>
* <<_generic, `GENERIC` category>>


[#_performance_notifications]
== `PERFORMANCE` category

Performance notifications are returned whenever the query uses costly operations and the performance may be improved by changing the query or adding an index.

[#_neo_clientnotification_statement_cartesianproduct]
=== CartesianProduct

.When is this notification returned?
[TIP]
====
Whenever there is a cartesian product in the plan.
====

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.CartesianProduct
|Title
a|This query builds a cartesian product between disconnected patterns.
|Severity
m|INFORMATION
|Category
m|PERFORMANCE
|===

.Cartesian product
====
Query::
+
[source, cypher, role="noplay"]
----
MATCH (c:Child), (p:Parent) RETURN c, p
----

Description of the returned code::
If a part of a query contains multiple disconnected patterns,
this will build a cartesian product between all those parts.
This may produce a large amount of data and slow down query processing.
While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product,
perhaps by adding a relationship between the different parts or by using `OPTIONAL MATCH` (identifier is: (`p`))

Suggestions for improvement::
In case a cartesian product is needed, nothing can be done to improve this query.
In many cases, however, you might not need a combination of all children and parents, and that is when this query could be improved.
If for example, you need the children and the children's parents, you can improve this query by rewriting it to the following:
+
[source, cypher, role="noplay"]
----
MATCH (c:Child)-[:ChildOf]->(p:Parent) RETURN c, p
----
====

[#_neo_clientnotification_statement_unboundedvariablelengthpattern]
=== UnboundedVariableLengthPattern

.When is this notification returned?
[TIP]
====
When there is no upper bound specified on the variable length relationship.
====

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.UnboundedVariableLengthPattern
|Title
a|The provided pattern is unbounded, consider adding an upper limit to the number of node hops.
|Severity
m|INFORMATION
|Category
m|PERFORMANCE
|===

.Shortest path with an unbounded pattern
====
Query::
+
[source, cypher, role="noplay"]
----
MATCH p=shortestPath((n)-[*]->(m)) RETURN p
----

Description of the returned code::
Using shortest path with an unbounded pattern will likely result in long execution times.
It is recommended to use an upper limit to the number of node hops in your pattern.

Suggestions for improvement::
If you have a big graph, this query might be very slow.
Consider adding an upper limit.
+
[source, cypher, role="noplay"]
----
MATCH p=shortestPath((n)-[*..8]->(m)) RETURN p
----
====

[#_neo_clientnotification_statement_exhaustiveshortestpath]
=== ExhaustiveShortestPath

.When is this notification returned?
[TIP]
====
When a predicate, given on the shortest path, needs to inspect the whole path before deciding whether it is valid, the shortest path might fall back to the exhaustive search algorithm.
For more information, see link:https://neo4j.com/docs/cypher-manual/current/execution-plans/shortestpath-planning#_shortest_pathadditional_predicate_checks_on_the_paths[Cypher manual -> Shortest path - additional predicate checks on the paths].
====

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.ExhaustiveShortestPath
|Title
a|Exhaustive shortest path has been planned for your query that means that shortest path graph algorithm might not be used to find the shortest path.
Hence an exhaustive enumeration of all paths might be used in order to find the requested shortest path.
|Severity
m|INFORMATION
|Category
m|PERFORMANCE
|===

.Exhaustive shortest path
====
[source, cypher, role="noplay"]
----
MATCH p = shortestPath(()-[*..42]-())
WHERE ANY(n in nodes(p) WHERE n:Label)
RETURN p
----

Description of the returned code::
Using shortest path with an exhaustive search fallback might cause query slow down since shortest path graph algorithms might not work for this use case.
It is recommended to introduce a `WITH` to separate the `MATCH` containing the shortest path from the existential predicates on that path.

Suggestions for improvement::
Separate the predicate by introducing a `WITH` after the `MATCH` clause.
+
[source, cypher, role="noplay"]
----
MATCH p = shortestPath(()-[*..42]-())
WITH p
WHERE ANY(n in nodes(p) WHERE n:Label)
RETURN p
----
====

[#_neo_clientnotification_statement_noapplicableindex]
=== NoApplicableIndex

.When is this notification returned?
[TIP]
====
Given a larger number of nodes, `LOAD CSV` together with a `MATCH` or a `MERGE` clause may speed up the query if you add an index.
====

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.NoApplicableIndex
|Title
a|Adding a schema index may speed up this query.
|Severity
m|INFORMATION
|Category
m|PERFORMANCE
|===

.Load CSV with `MATCH` or `MERGE`
====
Query::
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line WITH * MATCH (n:Person{name:line[0]}) RETURN line, n
----

Description of the returned code::
Using `LOAD CSV` followed by a `MATCH` or `MERGE` that matches a non-indexed label will most likely not perform well on large data sets.
Please consider using a schema index.

Suggestions for improvement::
Create an index on the label and property you match.
+
[source, cypher, role="noplay"]
----
CREATE INDEX FOR (n:Person) ON (n.name)
----
====

[#_neo_clientnotification_statement_eageroperator]
=== EagerOperator

.When is this notification returned?
[TIP]
====
When the execution plan for a query contains an eager operator.
====

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.EagerOperator
|Title
a|The execution plan for this query contains the Eager operator, which forces all dependent data to be materialized in main memory before proceeding
|Severity
m|INFORMATION
|Category
m|PERFORMANCE
|===

.Load CSV with `MATCH` or `MERGE`
====

`LOAD CSV` together with an Eager operator can take up a lot of memory.

Query::
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line MATCH (n:Person{name:line[0]}) DELETE n RETURN line
----

Description of the returned code::
Using `LOAD CSV` with a large data set in a query where the execution plan contains the Eager operator could potentially consume a lot of memory and is likely to not perform well.
See the Neo4j Manual entry on the Eager operator for more information and hints on how problems could be avoided.

Suggestions for improvement::
See the link:https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/operators/operators-detail/#query-plan-eager[Cypher Manual -> Eager operator] for more information and hints on how to avoid problems.
In this specific case, the query could be rewritten to the following:
+
[source, cypher, role="noplay"]
----
LOAD CSV FROM 'file:///ignore/ignore.csv' AS line
CALL {
    WITH line
    MATCH (n:Person{name:line[0]}) DELETE n
}
RETURN line
----
====

[#_neo_clientnotification_statement_dynamicproperty]
=== DynamicProperty

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.DynamicProperty
|Title
a|Queries using dynamic properties will use neither index seeks nor index scans for those properties
|Severity
m|INFORMATION
|Category
m|PERFORMANCE
|===

.Using a dynamic node property key makes it impossible to use indexes
====

Query::
+
[source, cypher]
----
MATCH (n:Person) WHERE n[$prop] IS NOT NULL RETURN n;
----

Description of the returned code::
Did not supply query with enough parameters. The produced query plan will not be cached and is not executable without `EXPLAIN`. (Missing parameters: `prop`)

Suggestions for improvement::
If there is an index for `(n:Person) ON (n.name)`, it will not be used for the above query because the query is using a dynamic property.
Therefore, if there is an index, it is better to use the constant value.
For example, if `prop` is equal to `name`, the following query would be able to use the index:
+
[source, cypher]
----
MATCH (n:Person) WHERE n.name IS NOT NULL RETURN n;
----
====

.Using dynamic relationship property key makes it impossible to use indexes
====
Query::
+
[source,cypher]
----
MATCH ()-[r: KNOWS]->() WHERE r[$prop] IS NOT NULL RETURN r
----

Description of the returned code::
Did not supply query with enough parameters. The produced query plan will not be cached and is not executable without `EXPLAIN`. (Missing parameters: `prop`)

Suggestions for improvement::
Similar to dynamic node properties, use a constant value if possible, especially when there is an index on the relationship property.
For example, if `$prop` is equal to `since`, you can rewrite the query to:
+
[source, cypher]
----
MATCH ()-[r: KNOWS]->() WHERE r.since IS NOT NULL RETURN r
----

====

[#_neo_clientnotification_statement_codegenerationfailed]
=== CodeGenerationFailed

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.CodeGenerationFailed
|Title
a|The database was unable to generate code for the query. A stack trace can be found in the _debug.log_.
|Severity
m|INFORMATION
|Category
m|PERFORMANCE
|===

The `CodeGenerationFailed` notification is created when it is not possible to generate a code for a query, for example, when the query is too big.
To find more information about the specific query, see the stack trace in the _debug.log_ file.

[#_hint_notifications]
== `HINT` category

`HINT` notifications are returned by default when the Cypher planner or runtime cannot create a query plan to fulfill a specified hint, for example, `JOIN` or `INDEX`.
This behavior of the Cypher planner or runtime can be changed by setting the configuration `dbms.cypher.hints_error` to `true`, in which case, the query will return an error instead.

[#_neo_clientnotification_statement_joinhintunfulfillablewarning]
=== JoinHintUnfulfillableWarning

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.JoinHintUnfulfillableWarning
|Title
a|The database was unable to plan a hinted join.
|Severity
m|WARNING
|Category
m|HINT
|===

.A `JOIN` hint was given, but it was not possible to fulfill the hint.
====
Query::
+
[source, cypher]
----
MATCH (a:A)
WITH a, 1 AS horizon
OPTIONAL MATCH (a)-[r]->(b:B)
USING JOIN ON a
OPTIONAL MATCH (a)--(c)
RETURN *
----

Description of the returned code::
The hinted join was not planned.
This could happen because no generated plan contained the join key,
please try using a different join key or restructure your query. (hinted join key identifier is: `a`)

Suggestions for improvement::
The join hint cannot be fulfilled because the given `JOIN` variable was introduced before the optional match and is therefore already bound.
The only option for this query is to remove the hint or change the query so it is possible to use the hint.
====

[#_neo_clientnotification_schema_hintedindexnotfound]
=== HintedIndexNotFound

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Schema.HintedIndexNotFound
|Title
a|The request (directly or indirectly) referred to an index that does not exist.
|Severity
m|WARNING
|Category
m|HINT
|===

.An index hint was given, but it was not possible to use the index.
====
Query::
+
[source, cypher]
----
MATCH (a: Label)
USING INDEX a:Label(id)
WHERE a.id = 1
RETURN a
----

Description of the returned code::
The hinted index does not exist, please check the schema (index is: INDEX FOR (`a`:`Label`) ON (`a`.`id`))

Suggestions for improvement::
The hinted index does not exist, make sure the label and property are spelled correctly.
If the spelling is correct, either create the index or remove the hint from the query.

====

.A relationship index hint was given, but it was not possible to use the index
====
Query::
+
[source, cypher]
----
MATCH ()-[r:Rel]-()
USING INDEX r:Rel(id)
WHERE r.id = 1
RETURN r
----

Description of the returned code::
The hinted index does not exist, please check the schema (index is: INDEX FOR ()-[`r`:`Rel`]-() ON (`r`.`id`))

Suggestions for improvement::
The hinted index does not exist, make sure the label and property are spelled correctly.
If the spelling is correct, either create the index or remove the hint from the query.

====

[#_unrecognized_notifications]
== `UNRECOGNIZED` category

A notification has the unrecognized category if the query or command mentions entities that are unknown to the system.

[#_neo_clientnotification_database_homedatabasenotfound]
=== HomeDatabaseNotFound

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Database.HomeDatabaseNotFound
|Title
a|The request referred to a home database that does not exist.
|Severity
m|INFORMATION
|Category
m|UNRECOGNIZED
|===

.Set the `home` database to a database that does not yet exist.
====
Query::
+
[source,cypher]
----
CREATE USER linnea SET PASSWORD "password" SET HOME DATABASE NonExistingDatabase
----

Description of the returned code::
The home database provided does not currently exist in the DBMS.
This command will not take effect until this database is created. (HOME DATABASE: `nonexistingdatabase`)

Suggestions for improvement::
Make sure the home database has not been misspelled.

====

[#_neo_clientnotification_statement_unknownlabelwarning]
=== UnknownLabelWarning

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.UnknownLabelWarning
|Title
a|The provided label is not in the database.
|Severity
m|WARNING
|Category
m|UNRECOGNIZED
|===

.Match on a node with a label that does not exist in the database.
====
Query::
+
[source,cypher]
----
MATCH (n:Perso) RETURN n
----

Description of the returned code::
One of the labels in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing label name is: `Perso`)

Suggestions for improvement::
Make sure you didn't misspell the label. If nodes with the given label will be created in the future, then no change is needed.

====

[#_neo_clientnotification_statement_unknownrelationshiptypewarning]
=== UnknownRelationshipTypeWarning

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning
|Title
a|The provided relationship type is not in the database.
|Severity
m|WARNING
|Category
m|UNRECOGNIZED
|===

.Match on a relationship, where there are no relationships in the database with the given relationship type.
====
Query::
+
[source,cypher]
----
MATCH (n)-[:NonExistingType]->() RETURN n
----

Description of the returned code::
One of the relationship types in your query is not available in the database,
make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: `NonExistingType`)

Suggestions for improvement::
Make sure you did not misspell the relationship type.
If relationships will be created, with the given relationship type, in the future, then no change to the query is needed.

====

[#_neo_clientnotification_statement_unknownpropertykeywarning]
=== UnknownPropertyKeyWarning

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.UnknownPropertyKeyWarning
|Title
a|The provided property key is not in the database
|Severity
m|WARNING
|Category
m|UNRECOGNIZED
|===

.Match on a property key that does not exist.
====
Query::
+
[source,cypher]
----
MATCH (n {nonExistingProp:1}) RETURN n
----

Description of the returned code::
One of the property names in your query is not available in the database,
make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: `nonExistingProp`)

Suggestions for improvement::
Make sure you didn't misspell the property key. If the property key will be created in the future, then no change is needed to the query.

====

[#_unsupported_notifications]
== `UNSUPPORTED` category

Notifications with the unsupported category are created if the query or command is trying to use features that are not supported by the current system or using experimental features that should not be used in production.

[#_neo_clientnotification_statement_runtimeunsupportedwarning]
=== RuntimeUnsupportedWarning

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.RuntimeUnsupportedWarning
|Title
a|This query is not supported by the chosen runtime.
|Severity
m|WARNING
|Category
m|UNSUPPORTED
|===

.The chosen runtime is not supported for the given query
====
Query::
+
[source,cypher]
----
CYPHER runtime=pipelined SHOW INDEXES YIELD *
----

Description of the returned code::
Selected runtime is unsupported for this query, please use a different runtime instead or fallback to default.
(Pipelined does not yet support the plans including `ShowIndexes`, use another runtime.)

Suggestions for improvement::
Use a different runtime or remove the runtime option to run the query with the default runtime:
+
[source,cypher]
----
SHOW INDEXES YIELD *
----
====

[#_neo_clientnotification_statement_runtimeexperimental]
=== RuntimeExperimental

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.RuntimeExperimental
|Title
a|This feature is experimental and should not be used in production systems.
|Severity
m|WARNING
|Category
m|UNSUPPORTED
|===

.Use of the parallel runtime
====
Query::
+
[source,cypher]
----
CYPHER runtime=parallel MATCH (n) RETURN (n)
----

Description of the returned code::
You are using an experimental feature (The parallel runtime is experimental and might suffer from instability and potentially correctness issues.)

Suggestions for improvement::
The parallel runtime should not be used in production. Choose another runtime or remove the option to use the default runtime:
+
[source,cypher]
----
MATCH (n) RETURN (n)
----
====

[#_deprecated_notifications]
== `DEPRECATION` category

Notifications within the deprecation category contain information about a feature or functionality which has been deprecated. It is important to change to the new functionality, otherwise, the query might break in a future version.

[#_neo_clientnotification_statement_featuredeprecationwarning]
=== FeatureDeprecationWarning

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.FeatureDeprecationWarning
|Title
a|This feature is deprecated and will be removed in future versions.
|Severity
m|WARNING
|Category
m|DEPRECATION
|===

.Colon after the | in a relationship pattern
====
Query::
+
[source,cypher]
----
MATCH (a)-[:A|:B|:C]-() RETURN *
----

Description of the returned code::
The semantics of using colon in the separation of alternative relationship types will change in a future version. (Please use ':A|B|C' instead)

Suggestions for improvement::
Remove the colon inside the relationship type expression.
+
[source,cypher]
----
MATCH (a)-[:A|B|C]-() RETURN *
----
====

.Setting properties using a node
====
Query::
+
[source,cypher]
----
MATCH (a)-[]-(b)
SET a = b
----

Description of the returned code::
The use of nodes or relationships for setting properties is deprecated and will be removed in a future version. Please use `properties()` instead.

Suggestions for improvement::
Use the `properties()` function to get all properties from `b`.
+
[source,cypher]
----
MATCH (a)-[]-(b)
SET a = properties(b)
----
====

.Setting properties using a relationship
====
Query::
+
[source,cypher]
----
MATCH (a)-[r]-(b)
SET a += r
----

Description of the returned code::
The use of nodes or relationships for setting properties is deprecated and will be removed in a future version. Please use `properties()` instead.

Suggestions for improvement::
Use the `properties()` function to get all properties from `r`
+
[source,cypher]
----
MATCH (a)-[r]-(b)
SET a += properties(r)
----
====

.Shortest path with a fixed relationship length
====
Query::
+
[source,cypher]
----
MATCH (a:Start), shortestPath((a)-[r]->()) RETURN a
----

Description of the returned code::
The use of `shortestPath` and `allShortestPaths` with fixed length relationships is deprecated and will be removed in a future version.
Please use a path with a length of `1 [r*1..1]` instead or a `Match` with a `limit`.

Suggestions for improvement::
If the relationship length is fixed, there is no reason to search for the shortest path.
Instead, you can rewrite it to the following:
+
[source,cypher]
----
MATCH (a: Start)-[r]->(b: End) RETURN b LIMIT 1
----
====


.Create a database with an unescaped name containing a dot
====
Query::
+
[source,cypher]
----
CREATE DATABASE foo.bar
----

Description of the returned code::
Databases and aliases with unescaped `.` are deprecated unless to indicate that they belong to a composite database.
Names containing `.` should be escaped. (Name: `foo.bar`)

Suggestions for improvement::
If not intended for a composite database, escape the name with the character ```.
+
[source,cypher]
----
CREATE DATABASE `foo.bar`
----
====

.A procedure has been deprecated or renamed
====

[source,cypher]
----
CALL unsupported.dbms.shutdown
----

Description of the returned code::
The query used a deprecated procedure: `'unsupported.dbms.shutdown'`.

Suggestions for improvement::
Remove the use of the deprecated procedure.
If there is a suggested replacement, update to use the replacement instead.

====

.Using a deprecated runtime option
====
Query::
+
[source,cypher]
----
CYPHER runtime = interpreted MATCH (n) RETURN n
----

Description of the returned code::
The query used a deprecated runtime option. (`'runtime=interpreted'` is deprecated, please use `'runtime=slotted'` instead)

Suggestions for improvement::
Runtime `interpreted` is deprecated, use another runtime or remove the runtime option to use the default runtime.
+
[source,cypher]
----
MATCH (n) RETURN n
----
====

.Using the `text-1.0` index provider when creating a text index
====
Query::
+
[source,cypher]
----
CREATE TEXT INDEX FOR (n:Label) ON (n.prop) OPTIONS {indexProvider : 'text-1.0'}
----

Description of the returned code::
The `text-1.0` provider for text indexes is deprecated and will be removed in a future version.
Please use `text-2.0` instead.

Suggestions for improvement::
Update the option `indexProvider` with the value `text-2.0`.
+
[source,cypher]
----
CREATE TEXT INDEX FOR (n:Label) ON (n.prop) OPTIONS {indexProvider : 'text-2.0'}
----
====

.Using differently ordered return items in a `UNION` clause
====
Query::
+
[source,cypher]
----
RETURN 'val' as one, 'val' as two
UNION
RETURN 'val' as two, 'val' as one
----

Description of the returned code::
All subqueries in a UNION [ALL] should have the same ordering for the return columns.
Using differently ordered return items in a UNION [ALL] clause is deprecated and will be removed in a future version.

Suggestions for improvement::
Use the same order for the return columns in all subqueries combined by a `UNION` clause.

+
[source,cypher]
----
RETURN 'val' as one, 'val' as two
UNION
RETURN 'val' as one, 'val' as two
----
====

.Using id() function
====
Query::
+
[source,cypher]
----
MATCH (a)
RETURN id(a)
----
Description of the returned code::
The query used a deprecated function: `id`.
Suggestions for improvement::
Use the function `elementId()` instead.
+
[source,cypher]
----
MATCH (a)
RETURN elementId(a)
----
====

.Using Cypher query option connectComponentsPlanner
====
Query::
+
[source,cypher]
----
CYPHER connectComponentsPlanner=greedy MATCH (a), (b) RETURN *
----
Description of the returned code::
The Cypher query option `connectComponentsPlanner` is deprecated and will be removed without a replacement.
The product's default behavior of using a cost-based IDP search algorithm when combining sub-plans will be kept.
For more information, see link:https://neo4j.com/docs/cypher-manual/current/query-tuning/query-options/#cypher-planner[Cypher manual -> Cypher planner].
====

[#_neo_clientnotification_request_deprecatedformat]
=== DeprecatedFormat


.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Request.DeprecatedFormat
|Title
a|The client requested a deprecated format.
|Severity
m|WARNING
|Category
m|DEPRECATION
|===

[#_security_notifications]
== `SECURITY` category

Security notifications indicate that the result of the query or command might have a potential security issue.
Verify that this is the intended behavior of your query or command.

[#_neo_clientnotification_security_commandhasnoeffect]
=== CommandHasNoEffect

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Security.CommandHasNoEffect
|Title
a|`<command>` has no effect.*
|Severity
m|INFORMATION
|Category
m|SECURITY
|===

*_`<command>` could be either the full command given by the user or a subset of the given command._

.Granting a role to a user who already has that role
====
Command::
+
[source, cypher]
----
GRANT ROLE admin TO john
----

Full title of the returned code::
`GRANT ROLE admin TO john` has no effect.

Description of the returned code::
The user already has the role. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and user.
====

.Revoking a role from a user who does not have that role
====
Command::
+
[source, cypher]
----
REVOKE ROLE admin, reader FROM jane
----

Full title of the returned code::
`REVOKE ROLE reader FROM jane` has no effect.

Description of the returned code::
The user does not have the role. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and user.
====

.Granting or denying a privilege to a role that already has that privilege
====
// This command returns 2 notifications, one for NODES and one for RELATIONSHIPS.
Command::
+
[source, cypher]
----
GRANT TRAVERSE ON GRAPH * TO reader
----

Full title of the returned code::
`GRANT TRAVERSE ON GRAPH * NODE * TO reader` has no effect.

Description of the returned code::
The role already has the privilege. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended privilege and role.
====

.Revoking a privilege from a role that does not have that privilege
====
Command::
+
[source, cypher]
----
REVOKE WRITE ON GRAPH * FROM reader
----

Full title of the returned code::
`REVOKE DENY WRITE ON GRAPH * FROM reader` has no effect.

Description of the returned code::
The role does not have the privilege. See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended privilege and role.
====

[#_neo_clientnotification_security_impossiblerevokecommand]
=== ImpossibleRevokeCommand

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Security.ImpossibleRevokeCommand
|Title
a|`<command>` has no effect.*
|Severity
m|WARNING
|Category
m|SECURITY
|===

*_`<command>` could be either the full command given by the user or a subset of the given command._

.Revoking a non-existing role from a user
====
Command::
+
[source, cypher]
----
REVOKE ROLE manager, reader FROM jane
----

Full title of the returned code::
`REVOKE ROLE manager FROM jane` has no effect.

Description of the returned code::
Role does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and that it is spelled correctly.
====

.Revoking a role from a non-existing user
====
Command::
+
[source, cypher]
----
REVOKE ROLE reader FROM alice
----

Full title of the returned code::
`REVOKE ROLE reader FROM alice` has no effect.

Description of the returned code::
User does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended user and that it is spelled correctly.
====

.Revoking a privilege from a non-existing role
====
Command::
+
[source, cypher]
----
REVOKE GRANT WRITE ON GRAPH * FROM manager
----

Full title of the returned code::
`REVOKE GRANT WRITE ON GRAPH * FROM manager` has no effect.

Description of the returned code::
Role does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended role and that it is spelled correctly.
====

.Revoking a privilege on a non-existing graph from a role
====
Command::
+
[source, cypher]
----
REVOKE GRANT WRITE ON GRAPH neo3j FROM editor
----

Full title of the returned code::
`REVOKE GRANT WRITE ON GRAPH neo3j FROM editor` has no effect.

Description of the returned code::
// We use 'Database' here for multiple reasons
// - The user fixes the issue by doing 'create database', not 'create graph'.
// - This matches the existing behaviour when granting the privilege.
// - It is easier to implement this way.
Database 'neo3j' does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended graph and that it is spelled correctly.
====

.Revoking a privilege on a non-existing database from a role
====
Command::
+
[source, cypher]
----
REVOKE GRANT ACCESS ON DATABASE neo3j FROM editor
----

Full title of the returned code::
`REVOKE GRANT ACCESS ON DATABASE neo3j FROM editor` has no effect.

Description of the returned code::
Database 'neo3j' does not exist. Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Verify that this is the intended database and that it is spelled correctly.
====

.Revoking a privilege from a role with wildcard graph parameter
====
Parameter::
+
[source, javascript]
----
{
    "graph": "*"
}
----
Command::
+
[source, cypher]
----
REVOKE GRANT CREATE ON GRAPH $graph FROM PUBLIC
----

Full title of the returned code::
`REVOKE GRANT CREATE ON GRAPH $graph FROM PUBLIC` has no effect.

Description of the returned code::
Parameterized database and graph names do not support wildcards.
Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Use `GRAPH *` without the parameter to revoke the privilege on all graphs.
====

.Revoking a privilege from a role with wildcard database parameter
====
Parameter::
+
[source, javascript]
----
{
    "database": "*"
}
----
Command::
+
[source, cypher]
----
REVOKE GRANT ACCESS ON DATABASE $database FROM PUBLIC
----

Full title of the returned code::
`REVOKE GRANT ACCESS ON DATABASE $database FROM PUBLIC` has no effect.

Description of the returned code::
Parameterized database and graph names do not support wildcards.
Make sure nothing is misspelled.
This notification will become an error in a future major version.
See Status Codes documentation for more information.

Suggestions for improvement::
Use `DATABASE *` without the parameter to revoke the privilege on all databases.
====

[#_topology_notifications]
== `TOPOLOGY` category

Topology notifications provide additional information related to managing databases and servers.

[#_neo_clientnotification_cluster_cordonedserversexistedduringallocation]
=== CordonedServersExistedDuringAllocation

.When is this notification returned?
[TIP]
====
When a Cypher administration command triggers an allocation decision and some of the servers are cordoned.
For example, `CREATE DATABASE`, `ALTER DATABASE`, `DEALLOCATE DATABASES FROM SERVER[S]`, and `ALTER DATABASE` return this notification. However, `REALLOCATE DATABASES` requires that there are no cordoned servers and, therefore, does not return it.
====

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Cluster.CordonedServersExistedDuringAllocation
|Title
a| Cordoned servers existed when making an allocation decision.
|Severity
m|INFORMATION
|Category
m|TOPOLOGY
|===

.Cordoned servers existed during an allocation decision
====
The example assumes that you have a cluster with three servers, of which server `123e4567-e89b-12d3-a456-426614174000` is cordoned using the `dbms.cluster.cordonServer` procedure. Then the below command will return this notification.

Command::
+
[source, cypher]
----
CREATE DATABASE foo TOPOLOGY 2 PRIMARIES
----

Description of the returned code::
Server(s) `123e4567-e89b-12d3-a456-426614174000` are cordoned. This can impact allocation decisions.
====

[#_neo_clientnotification_cluster_nodatabasesreallocated]
=== NoDatabasesReallocated

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Cluster.NoDatabasesReallocated
|Title
a| `<command>` has no effect.
|Severity
m|INFORMATION
|Category
m|TOPOLOGY
|===

.Reallocating databases resulted in no allocation changes 
====
Command::
+
[source, cypher]
----
REALLOCATE DATABASES
----

Description of the returned code::
No databases were reallocated. No better allocation is currently possible. 


Example scenarios::
**Scenario 1:** The cluster is already balanced. 
For example, when there are three servers, each hosting databases `foo` and `bar`, meaning all databases are allocated to all servers.
+

**Scenario 2:** The cluster appears unbalanced, but server constraints prevent you from moving to a better, more balanced, allocation. For example, assuming server 1 hosts databases `foo` and `bar`, server 2 hosts only `foo`, and server 3 hosts no databases. Then, a better allocation would move `foo` from server 1 to server 3, but if server 3 has the constraint `deniedDatabases:['foo']}`, then the cluster is already balanced subject to this constraint.
====

[#_neo_clientnotification_cluster_serveralreadyenabled]
=== ServerAlreadyEnabled

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Cluster.ServerAlreadyEnabled
|Title
a| `<command>` has no effect.
|Severity
m|INFORMATION
|Category
m|TOPOLOGY
|===

.Enabling an already enabled server
====
Command::
+
[source, cypher]
----
ENABLE SERVER "123e4567-e89b-12d3-a456-426614174000"
----

Description of the returned code::
Server `123e4567-e89b-12d3-a456-426614174000` is already enabled.
Verify that this is the intended server.

====

[#_generic]
== `GENERIC` category

`GENERIC` notification codes do not belong to any wider category and do not have any connection to each other.

[#_neo_clientnotification_statement_subqueryvariableshadowing]
=== SubqueryVariableShadowing

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.SubqueryVariableShadowing
|Title
a|Variable in subquery is shadowing a variable with the same name from the outer scope.
|Severity
m|INFORMATION
|Category
m|GENERIC
|===

.Shadowing of a variable from the outer scope
====
Query::
+
[source,cypher]
----
MATCH (n)
CALL {
  MATCH (n)--(m)
  RETURN m
}
RETURN *
----

Description of the returned code::
Variable in subquery is shadowing a variable with the same name from the outer scope.
If you want to use that variable instead, it must be imported into the subquery using importing `WITH` clause. (the shadowing variable is: `n`)

Suggestions for improvement::
If the intended behavior of the query is for the variable in the subquery to be a new variable, then nothing needs to be done.
If the intended behavior is to use the variable from the outer query, it needs to be imported to the subquery using the with clause.
+
[source,cypher]
----
MATCH (n)
CALL {
  WITH n
  MATCH (n)--(m)
  RETURN m
}
RETURN *
----
====


[#_neo_clientnotification_statement_parameternotprovided]
=== ParameterNotProvided

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.ParameterNotProvided
|Title
a|The statement refers to a parameter that was not provided in the request.
|Severity
m|WARNING
|Category
m|GENERIC
|===

.Using an `EXPLAIN` query with parameters without providing them
====
Query::
+
[source,cypher]
----
EXPLAIN WITH $param as param RETURN param
----

Description of the returned code::
Did not supply query with enough parameters.
The produced query plan will not be cached and is not executable without `EXPLAIN`. (Missing parameters: `param`)

Suggestions for improvement::
Provide the parameter to be able to cache the plan.

====

[#_neo_clientnotification_procedure_procedurewarning]
=== ProcedureWarning

.Notification details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Procedure.ProcedureWarning
|Title
a|The query used a procedure that generated a warning.
|Severity
m|WARNING
|Category
m|GENERIC
|===

[#_neo_clientnotification_statement_unsatisfiablerelationshiptypeexpression]
=== UnsatisfiableRelationshipTypeExpression

label:introduced-in-Neo4j-5.4[Introduced in Neo4j 5.4]

.When is this notification returned?
[TIP]
====
When matching on a relationship type expression that can never be satisfied, for example asking for zero, more than one or contradictory types.
====

.Notification category details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.UnsatisfiableRelationshipTypeExpression
|Title
a|The query contains a relationship type expression that cannot be satisfied.
|Severity
m|WARNING
|Category
m|GENERIC
|===

.Matching on a relationship type expression that can never be satisfied
====
Query::
+
[source,cypher]
----
MATCH ()-[r:R1&R2]->() RETURN r
----
Description of the returned code::
Relationship type expression cannot possibly be satisfied. (`R1&R2` can never be fulfilled by any relationship. Relationships must have exactly one type.)
====

[#_neo_clientnotification_statement_repeatedrelationshipreference]
=== Neo.ClientNotification.Statement.RepeatedRelationshipReference

.Notification category details
[cols="<1s,<4"]
|===
|Code
m|Neo.ClientNotification.Statement.RepeatedRelationshipReference
|Title
a|The query returns no results because a relationship variable is bound more than once.
|Severity
m|WARNING
|Category
m|GENERIC
|===

.Binding a relationship variable more than once (when run on version 5.5 or newer)
====
Query::
+
[source,cypher]
----
MATCH (:A)-[r]->(), ()-[r]->(:B) RETURN r
----
Description of the returned code::
A relationship is referenced more than once in the query, which leads to no results because relationships must not occur more than once in each result. (Relationship `r` was repeated)

Suggestions for improvement::
Use one pattern to match all relationships that start with a node with the label `A` and end with a node with the label `B`:
+
[source, cypher, role="noplay"]
----
MATCH (:A)-[r]->(:B) RETURN r
----
====

.Binding a variable-length relationship variable more than once (when run on version 5.6 or newer)
====
Query::
+
[source,cypher]
----
MATCH ()-[r*]->()<-[r*]-() RETURN count(*) AS count
----
Description of the returned code::
A variable-length relationship variable is bound more than once, which leads to no results because relationships must not occur more than once in each result. (Relationship r was repeated)
====
